{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 7, "column": 0}, "map": {"version":3,"file":"index.es.js","sources":["file:///Users/alex/code/Personal_Projects/web3-social-app/node_modules/.pnpm/%40walletconnect%2Btypes%402.21.0/node_modules/%40walletconnect/types/src/core/core.ts","file:///Users/alex/code/Personal_Projects/web3-social-app/node_modules/.pnpm/%40walletconnect%2Btypes%402.21.0/node_modules/%40walletconnect/types/src/core/crypto.ts","file:///Users/alex/code/Personal_Projects/web3-social-app/node_modules/.pnpm/%40walletconnect%2Btypes%402.21.0/node_modules/%40walletconnect/types/src/core/history.ts","file:///Users/alex/code/Personal_Projects/web3-social-app/node_modules/.pnpm/%40walletconnect%2Btypes%402.21.0/node_modules/%40walletconnect/types/src/core/messages.ts","file:///Users/alex/code/Personal_Projects/web3-social-app/node_modules/.pnpm/%40walletconnect%2Btypes%402.21.0/node_modules/%40walletconnect/types/src/core/publisher.ts","file:///Users/alex/code/Personal_Projects/web3-social-app/node_modules/.pnpm/%40walletconnect%2Btypes%402.21.0/node_modules/%40walletconnect/types/src/core/relayer.ts","file:///Users/alex/code/Personal_Projects/web3-social-app/node_modules/.pnpm/%40walletconnect%2Btypes%402.21.0/node_modules/%40walletconnect/types/src/core/store.ts","file:///Users/alex/code/Personal_Projects/web3-social-app/node_modules/.pnpm/%40walletconnect%2Btypes%402.21.0/node_modules/%40walletconnect/types/src/core/subscriber.ts","file:///Users/alex/code/Personal_Projects/web3-social-app/node_modules/.pnpm/%40walletconnect%2Btypes%402.21.0/node_modules/%40walletconnect/types/src/core/keychain.ts","file:///Users/alex/code/Personal_Projects/web3-social-app/node_modules/.pnpm/%40walletconnect%2Btypes%402.21.0/node_modules/%40walletconnect/types/src/core/expirer.ts","file:///Users/alex/code/Personal_Projects/web3-social-app/node_modules/.pnpm/%40walletconnect%2Btypes%402.21.0/node_modules/%40walletconnect/types/src/core/pairing.ts","file:///Users/alex/code/Personal_Projects/web3-social-app/node_modules/.pnpm/%40walletconnect%2Btypes%402.21.0/node_modules/%40walletconnect/types/src/core/verify.ts","file:///Users/alex/code/Personal_Projects/web3-social-app/node_modules/.pnpm/%40walletconnect%2Btypes%402.21.0/node_modules/%40walletconnect/types/src/core/echo.ts","file:///Users/alex/code/Personal_Projects/web3-social-app/node_modules/.pnpm/%40walletconnect%2Btypes%402.21.0/node_modules/%40walletconnect/types/src/core/events.ts","file:///Users/alex/code/Personal_Projects/web3-social-app/node_modules/.pnpm/%40walletconnect%2Btypes%402.21.0/node_modules/%40walletconnect/types/src/sign-client/client.ts","file:///Users/alex/code/Personal_Projects/web3-social-app/node_modules/.pnpm/%40walletconnect%2Btypes%402.21.0/node_modules/%40walletconnect/types/src/sign-client/engine.ts"],"sourcesContent":["import { IEvents } from \"@walletconnect/events\";\nimport { IHeartBeat } from \"@walletconnect/heartbeat\";\nimport { IKeyValueStorage, KeyValueStorageOptions } from \"@walletconnect/keyvaluestorage\";\n\nimport { ICrypto } from \"./crypto\";\nimport { IRelayer } from \"./relayer\";\nimport { IKeyChain } from \"./keychain\";\nimport { IJsonRpcHistory } from \"./history\";\nimport { IExpirer } from \"./expirer\";\nimport { IPairing } from \"./pairing\";\nimport { Logger } from \"@walletconnect/logger\";\nimport { IVerify } from \"./verify\";\nimport { IEchoClient } from \"./echo\";\nimport { IEventClient } from \"./events\";\nexport declare namespace CoreTypes {\n  interface Options {\n    projectId?: string;\n    name?: string;\n    relayUrl?: string;\n    logger?: string | Logger;\n    keychain?: IKeyChain;\n    storage?: IKeyValueStorage;\n    storageOptions?: KeyValueStorageOptions;\n    maxLogBlobSizeInBytes?: number;\n    customStoragePrefix?: string;\n    telemetryEnabled?: boolean;\n  }\n\n  interface Metadata {\n    name: string;\n    description: string;\n    url: string;\n    icons: string[];\n    verifyUrl?: string;\n    redirect?: {\n      native?: string;\n      universal?: string;\n      linkMode?: boolean;\n    };\n  }\n}\n\nexport abstract class ICore extends IEvents {\n  public readonly protocol = \"wc\";\n  public readonly version = 2;\n\n  public abstract readonly name: string;\n  public abstract readonly context: string;\n  public abstract readonly relayUrl?: string;\n  public abstract readonly projectId?: string;\n  public abstract readonly customStoragePrefix: string;\n\n  public abstract logger: Logger;\n  public abstract heartbeat: IHeartBeat;\n  public abstract crypto: ICrypto;\n  public abstract relayer: IRelayer;\n  public abstract storage: IKeyValueStorage;\n  public abstract history: IJsonRpcHistory;\n  public abstract expirer: IExpirer;\n  public abstract pairing: IPairing;\n  public abstract verify: IVerify;\n  public abstract echoClient: IEchoClient;\n  public abstract linkModeSupportedApps: string[];\n  public abstract eventClient: IEventClient;\n\n  constructor(public opts?: CoreTypes.Options) {\n    super();\n  }\n\n  public abstract start(): Promise<void>;\n  public abstract dispatchEnvelope(params: {\n    topic: string;\n    message: string;\n    sessionExists: boolean;\n  }): void;\n\n  public abstract addLinkModeSupportedApp(universalLink: string): void;\n}\n","import { JsonRpcPayload } from \"@walletconnect/jsonrpc-types\";\nimport { Logger } from \"@walletconnect/logger\";\nimport { ICore } from \"./core\";\nimport { IKeyChain } from \"./keychain\";\n\nexport declare namespace CryptoTypes {\n  export type EncodingType = \"base64pad\" | \"base64url\";\n\n  export interface Participant {\n    publicKey: string;\n  }\n\n  export interface KeyPair {\n    privateKey: string;\n    publicKey: string;\n  }\n\n  export interface EncryptParams {\n    message: string;\n    symKey: string;\n    type?: number;\n    iv?: string;\n    senderPublicKey?: string;\n    encoding?: EncodingType;\n  }\n\n  export interface DecryptParams {\n    symKey: string;\n    encoded: string;\n    encoding?: EncodingType;\n  }\n\n  export interface EncodingParams {\n    type: Uint8Array;\n    sealed: Uint8Array;\n    iv: Uint8Array;\n    senderPublicKey?: Uint8Array;\n    encoding?: EncodingType;\n  }\n\n  export interface DecodingParams {\n    encoded: string;\n    encoding?: EncodingType;\n  }\n\n  export interface EncodeOptions {\n    type?: number;\n    senderPublicKey?: string;\n    receiverPublicKey?: string;\n    encoding?: EncodingType;\n  }\n\n  export interface DecodeOptions {\n    receiverPublicKey?: string;\n    encoding?: EncodingType;\n  }\n\n  export interface EncodingValidation {\n    type: number;\n    senderPublicKey?: string;\n    receiverPublicKey?: string;\n  }\n\n  export interface TypeOneParams {\n    type: 1;\n    senderPublicKey: string;\n    receiverPublicKey: string;\n  }\n}\n\nexport abstract class ICrypto {\n  public abstract name: string;\n\n  public abstract readonly context: string;\n\n  public abstract keychain: IKeyChain;\n\n  public abstract readonly randomSessionIdentifier: string;\n\n  constructor(\n    public core: ICore,\n    public logger: Logger,\n    // @ts-ignore\n    keychain?: IKeyChain,\n  ) {}\n\n  public abstract init(): Promise<void>;\n\n  public abstract hasKeys(tag: string): boolean;\n\n  public abstract getClientId(): Promise<string>;\n\n  public abstract generateKeyPair(): Promise<string>;\n\n  public abstract generateSharedKey(\n    selfPublicKey: string,\n    peerPublicKey: string,\n    overrideTopic?: string,\n  ): Promise<string>;\n\n  public abstract setSymKey(symKey: string, overrideTopic?: string): Promise<string>;\n\n  public abstract deleteKeyPair(publicKey: string): Promise<void>;\n\n  public abstract deleteSymKey(topic: string): Promise<void>;\n\n  public abstract encode(\n    topic: string,\n    payload: JsonRpcPayload,\n    opts?: CryptoTypes.EncodeOptions,\n  ): Promise<string>;\n\n  public abstract decode(\n    topic: string,\n    encoded: string,\n    opts?: CryptoTypes.DecodeOptions,\n  ): Promise<JsonRpcPayload>;\n\n  public abstract signJWT(aud: string): Promise<string>;\n  public abstract getPayloadType(encoded: string, encoding?: CryptoTypes.EncodingType): number;\n  public abstract getPayloadSenderPublicKey(\n    encoded: string,\n    encoding?: CryptoTypes.EncodingType,\n  ): string | undefined;\n}\n","import { IEvents } from \"@walletconnect/events\";\nimport {\n  ErrorResponse,\n  JsonRpcRequest,\n  JsonRpcResponse,\n  RequestArguments,\n} from \"@walletconnect/jsonrpc-types\";\nimport { Logger } from \"@walletconnect/logger\";\n\nimport { ICore } from \"./core\";\n\nexport interface JsonRpcRecord {\n  id: number;\n  topic: string;\n  request: RequestArguments;\n  chainId?: string;\n  response?: { result: any } | { error: ErrorResponse };\n  expiry?: number;\n}\n\nexport interface RequestEvent {\n  topic: string;\n  request: JsonRpcRequest;\n  chainId?: string;\n}\n\nexport abstract class IJsonRpcHistory extends IEvents {\n  public records = new Map<number, JsonRpcRecord>();\n\n  public abstract readonly context: string;\n\n  public abstract readonly size: number;\n\n  public abstract readonly keys: number[];\n\n  public abstract readonly values: JsonRpcRecord[];\n\n  public abstract readonly pending: RequestEvent[];\n\n  constructor(\n    public core: ICore,\n    public logger: Logger,\n  ) {\n    super();\n  }\n\n  public abstract init(): Promise<void>;\n\n  public abstract set(topic: string, request: JsonRpcRequest, chainId?: string): void;\n\n  public abstract get(topic: string, id: number): Promise<JsonRpcRecord>;\n\n  public abstract resolve(response: JsonRpcResponse): Promise<void>;\n\n  public abstract delete(topic: string, id?: number): void;\n\n  public abstract exists(topic: string, id: number): Promise<boolean>;\n}\n","import { Logger } from \"@walletconnect/logger\";\nimport { ICore } from \"./core\";\n\nexport type MessageRecord = Record<string, string>;\n\nexport abstract class IMessageTracker {\n  public abstract messages: Map<string, MessageRecord>;\n  public abstract messagesWithoutClientAck: Map<string, MessageRecord>;\n\n  public abstract name: string;\n\n  public abstract readonly context: string;\n\n  constructor(\n    public logger: Logger,\n    public core: ICore,\n  ) {}\n\n  public abstract init(): Promise<void>;\n\n  public abstract set(\n    topic: string,\n    message: string,\n    direction?: \"inbound\" | \"outbound\",\n  ): Promise<string>;\n\n  public abstract get(topic: string): MessageRecord;\n\n  public abstract getWithoutAck(topics: string[]): Record<string, string[]>;\n\n  public abstract has(topic: string, message: string): boolean;\n\n  public abstract del(topic: string): Promise<void>;\n\n  public abstract ack(topic: string, message: string): Promise<void>;\n}\n","import { IEvents } from \"@walletconnect/events\";\nimport { Logger } from \"@walletconnect/logger\";\n\nimport { IRelayer, RelayerTypes } from \"./relayer\";\n\nexport declare namespace PublisherTypes {\n  export interface Params {\n    topic: string;\n    message: string;\n    opts: Omit<RelayerTypes.PublishOptions, \"internal\">;\n  }\n}\n\nexport abstract class IPublisher extends IEvents {\n  public abstract name: string;\n\n  public abstract readonly context: string;\n\n  constructor(\n    public relayer: IRelayer,\n    public logger: Logger,\n  ) {\n    super();\n  }\n\n  public abstract publish(\n    topic: string,\n    message: string,\n    opts?: RelayerTypes.PublishOptions,\n  ): Promise<void>;\n}\n","import { IEvents } from \"@walletconnect/events\";\nimport { IJsonRpcProvider, JsonRpcPayload, RequestArguments } from \"@walletconnect/jsonrpc-types\";\nimport { Logger } from \"@walletconnect/logger\";\n\nimport { ICore } from \"./core\";\nimport { IMessageTracker } from \"./messages\";\nimport { IPublisher } from \"./publisher\";\nimport { ISubscriber } from \"./subscriber\";\n\nexport declare namespace RelayerTypes {\n  export interface ProtocolOptions {\n    protocol: string;\n    data?: string;\n  }\n  export interface PublishOptions {\n    relay?: ProtocolOptions;\n    ttl?: number;\n    prompt?: boolean;\n    tag?: number;\n    id?: number;\n    internal?: {\n      throwOnFailedPublish?: boolean;\n    };\n    tvf?: ITVF;\n    attestation?: string;\n  }\n\n  export type TransportType = \"relay\" | \"link_mode\";\n\n  export interface SubscribeOptions {\n    relay?: ProtocolOptions;\n    transportType?: TransportType;\n    internal?: {\n      throwOnFailedPublish?: boolean;\n    };\n  }\n\n  export interface UnsubscribeOptions {\n    id?: string;\n    relay: ProtocolOptions;\n  }\n\n  export type RequestOptions = PublishOptions | SubscribeOptions | UnsubscribeOptions;\n\n  export interface PublishPayload {\n    topic: string;\n    message: string;\n    opts?: RelayerTypes.PublishOptions;\n  }\n  export interface MessageEvent {\n    topic: string;\n    message: string;\n    publishedAt: number;\n    transportType?: TransportType;\n    attestation?: string;\n  }\n\n  export interface RpcUrlParams {\n    protocol: string;\n    version: number;\n    auth: string;\n    relayUrl: string;\n    sdkVersion: string;\n    projectId?: string;\n    useOnCloseEvent?: boolean;\n    bundleId?: string;\n    packageName?: string;\n  }\n\n  export interface ITVF {\n    correlationId?: number;\n    rpcMethods?: string[];\n    chainId?: string;\n    txHashes?: string[];\n    contractAddresses?: string[];\n  }\n\n  export type MessageDirection = \"inbound\" | \"outbound\";\n}\n\nexport interface RelayerOptions {\n  core: ICore;\n  logger?: string | Logger;\n  relayUrl?: string;\n  projectId?: string;\n}\n\nexport interface RelayerClientMetadata {\n  protocol: string;\n  version: number;\n  env: string;\n  host?: string;\n}\n\nexport abstract class IRelayer extends IEvents {\n  public abstract protocol: string;\n\n  public abstract version: number;\n\n  public abstract core: ICore;\n\n  public abstract logger: Logger;\n\n  public abstract subscriber: ISubscriber;\n\n  public abstract publisher: IPublisher;\n\n  public abstract messages: IMessageTracker;\n\n  public abstract provider: IJsonRpcProvider;\n\n  public abstract name: string;\n\n  public abstract transportExplicitlyClosed: boolean;\n\n  public abstract readonly context: string;\n\n  public abstract readonly connected: boolean;\n\n  public abstract readonly connecting: boolean;\n\n  constructor(\n    // @ts-ignore\n    opts: RelayerOptions,\n  ) {\n    super();\n  }\n\n  public abstract init(): Promise<void>;\n\n  public abstract publish(\n    topic: string,\n    message: string,\n    opts?: RelayerTypes.PublishOptions,\n  ): Promise<void>;\n\n  public abstract request(request: RequestArguments): Promise<JsonRpcPayload>;\n\n  public abstract subscribe(topic: string, opts?: RelayerTypes.SubscribeOptions): Promise<string>;\n\n  public abstract unsubscribe(topic: string, opts?: RelayerTypes.UnsubscribeOptions): Promise<void>;\n  public abstract transportClose(): Promise<void>;\n  public abstract transportOpen(relayUrl?: string): Promise<void>;\n  public abstract restartTransport(relayUrl?: string): Promise<void>;\n  public abstract confirmOnlineStateOrThrow(): Promise<void>;\n  public abstract handleBatchMessageEvents(messages: RelayerTypes.MessageEvent[]): Promise<void>;\n  public abstract onLinkMessageEvent(\n    messageEvent: RelayerTypes.MessageEvent,\n    opts?: { sessionExists?: boolean },\n  ): Promise<void>;\n}\n","import { ErrorResponse } from \"@walletconnect/jsonrpc-types\";\nimport { Logger } from \"@walletconnect/logger\";\nimport { ICore } from \"./core\";\n\nexport abstract class IStore<Key, Value> {\n  public abstract map: Map<Key, Value>;\n\n  public abstract readonly context: string;\n\n  public abstract readonly length: number;\n\n  public abstract readonly keys: Key[];\n\n  public abstract readonly values: Value[];\n\n  constructor(\n    public core: ICore,\n    public logger: Logger,\n    public name: string,\n    // @ts-ignore\n    storagePrefix?: string,\n  ) {}\n\n  public abstract init(): Promise<void>;\n\n  public abstract set(key: Key, value: Value): Promise<void>;\n\n  public abstract get(key: Key): Value;\n\n  public abstract getAll(filter?: Partial<Value>): Value[];\n\n  public abstract update(key: Key, update: Partial<Value>): Promise<void>;\n\n  public abstract delete(key: Key, reason: ErrorResponse): Promise<void>;\n}\n","import { IEvents } from \"@walletconnect/events\";\nimport { ErrorResponse } from \"@walletconnect/jsonrpc-types\";\nimport { Logger } from \"@walletconnect/logger\";\n\nimport { IRelayer, RelayerTypes } from \"./relayer\";\n\nexport declare namespace SubscriberTypes {\n  export interface Params extends RelayerTypes.SubscribeOptions {\n    topic: string;\n  }\n\n  export interface Active extends Params {\n    id: string;\n  }\n}\n\nexport declare namespace SubscriberEvents {\n  export type Created = SubscriberTypes.Active;\n\n  export interface Deleted extends SubscriberTypes.Active {\n    reason: ErrorResponse;\n  }\n\n  export type Expired = Deleted;\n}\n\nexport abstract class ISubscriberTopicMap {\n  public map = new Map<string, string[]>();\n\n  public abstract readonly topics: string[];\n\n  public abstract set(topic: string, id: string): void;\n\n  public abstract get(topic: string): string[];\n\n  public abstract exists(topic: string, id: string): boolean;\n\n  public abstract delete(topic: string, id?: string): void;\n\n  public abstract clear(): void;\n}\n\nexport abstract class ISubscriber extends IEvents {\n  public abstract subscriptions: Map<string, SubscriberTypes.Active>;\n\n  public abstract topicMap: ISubscriberTopicMap;\n\n  public abstract pending: Map<string, SubscriberTypes.Params>;\n\n  public abstract readonly length: number;\n\n  public abstract readonly ids: string[];\n\n  public abstract readonly values: SubscriberTypes.Active[];\n\n  public abstract readonly topics: string[];\n\n  public abstract readonly hasAnyTopics: boolean;\n\n  public abstract name: string;\n\n  public abstract readonly context: string;\n\n  constructor(\n    public relayer: IRelayer,\n    public logger: Logger,\n  ) {\n    super();\n  }\n\n  public abstract init(): Promise<void>;\n\n  public abstract subscribe(\n    topic: string,\n    opts?: RelayerTypes.SubscribeOptions,\n  ): Promise<string | null>;\n\n  public abstract unsubscribe(topic: string, opts?: RelayerTypes.UnsubscribeOptions): Promise<void>;\n\n  public abstract isSubscribed(topic: string): Promise<boolean>;\n\n  public abstract isKnownTopic(topic: string): Promise<boolean>;\n\n  public abstract start(): Promise<void>;\n\n  public abstract stop(): Promise<void>;\n}\n","import { Logger } from \"@walletconnect/logger\";\nimport { ICore } from \"./core\";\n\nexport abstract class IKeyChain {\n  public abstract keychain: Map<string, string>;\n\n  public abstract name: string;\n\n  public abstract readonly context: string;\n\n  constructor(\n    public core: ICore,\n    public logger: Logger,\n  ) {}\n\n  public abstract init(): Promise<void>;\n\n  public abstract has(tag: string, opts?: any): boolean;\n\n  public abstract set(tag: string, key: string, opts?: any): Promise<void>;\n\n  public abstract get(tag: string, opts?: any): string;\n\n  public abstract del(tag: string, opts?: any): Promise<void>;\n}\n","import { IEvents } from \"@walletconnect/events\";\nimport { Logger } from \"@walletconnect/logger\";\n\nimport { ICore } from \"./core\";\n\nexport declare namespace ExpirerTypes {\n  interface Expiration {\n    target: string;\n    expiry: number;\n  }\n\n  interface Created {\n    target: string;\n    expiration: Expiration;\n  }\n\n  interface Deleted {\n    target: string;\n    expiration: Expiration;\n  }\n\n  interface Expired {\n    target: string;\n    expiration: Expiration;\n  }\n}\n\nexport abstract class IExpirer extends IEvents {\n  public abstract name: string;\n\n  public abstract readonly context: string;\n\n  public abstract readonly length: number;\n\n  public abstract readonly keys: string[];\n\n  public abstract readonly values: ExpirerTypes.Expiration[];\n\n  constructor(\n    public core: ICore,\n    public logger: Logger,\n  ) {\n    super();\n  }\n\n  public abstract init(): Promise<void>;\n\n  public abstract has(key: string | number): boolean;\n\n  public abstract set(key: string | number, expiry: number): void;\n\n  public abstract get(key: string | number): ExpirerTypes.Expiration;\n\n  public abstract del(key: string | number): void;\n}\n","import {\n  ErrorResponse,\n  JsonRpcRequest,\n  JsonRpcResponse,\n  JsonRpcResult,\n  JsonRpcError,\n} from \"@walletconnect/jsonrpc-types\";\nimport EventEmitter from \"events\";\n\nimport { ICore, CoreTypes } from \"./core\";\nimport { IStore } from \"./store\";\n\nimport { RelayerTypes } from \"../core/relayer\";\nimport { Logger } from \"@walletconnect/logger\";\n\nexport declare namespace PairingTypes {\n  interface Struct {\n    topic: string;\n    expiry: number;\n    relay: RelayerTypes.ProtocolOptions;\n    active: boolean;\n    peerMetadata?: CoreTypes.Metadata;\n    methods?: string[];\n  }\n}\n\nexport declare namespace PairingJsonRpcTypes {\n  // -- core ------------------------------------------------------- //\n  type DefaultResponse = true | ErrorResponse;\n\n  type WcMethod = \"wc_pairingDelete\" | \"wc_pairingPing\";\n\n  type Error = ErrorResponse;\n\n  // -- requests --------------------------------------------------- //\n\n  interface RequestParams {\n    wc_pairingDelete: {\n      code: number;\n      message: string;\n    };\n    wc_pairingPing: Record<string, unknown>;\n  }\n\n  // -- responses -------------------------------------------------- //\n  interface Results {\n    wc_pairingDelete: true;\n    wc_pairingPing: true;\n  }\n\n  // -- events ----------------------------------------------------- //\n  interface EventCallback<T extends JsonRpcRequest | JsonRpcResponse> {\n    topic: string;\n    payload: T;\n  }\n}\n\nexport type IPairingStore = IStore<string, PairingTypes.Struct>;\n\nexport abstract class IPairing {\n  public abstract name: string;\n  public abstract readonly context: string;\n  public abstract events: EventEmitter;\n  public abstract pairings: IPairingStore;\n\n  constructor(\n    public logger: Logger,\n    public core: ICore,\n  ) {}\n\n  public abstract init(): Promise<void>;\n\n  public abstract pair(params: {\n    uri: string;\n    activatePairing?: boolean;\n  }): Promise<PairingTypes.Struct>;\n\n  // for proposer to create inactive pairing\n  public abstract create(params?: {\n    methods?: string[];\n    transportType?: RelayerTypes.SubscribeOptions[\"transportType\"];\n  }): Promise<{ topic: string; uri: string }>;\n\n  // for either to activate a previously created pairing\n  public abstract activate(params: { topic: string }): Promise<void>;\n\n  // for both to subscribe on methods requests\n  public abstract register(params: { methods: string[] }): void;\n\n  // for either to update the expiry of an existing pairing.\n  public abstract updateExpiry(params: { topic: string; expiry: number }): Promise<void>;\n\n  // for either to update the metadata of an existing pairing.\n  public abstract updateMetadata(params: {\n    topic: string;\n    metadata: CoreTypes.Metadata;\n  }): Promise<void>;\n\n  // query pairings\n  public abstract getPairings(): PairingTypes.Struct[];\n\n  // for either to ping a peer\n  public abstract ping(params: { topic: string }): Promise<void>;\n\n  // for either peer to disconnect a pairing\n  public abstract disconnect(params: { topic: string }): Promise<void>;\n\n  public abstract formatUriFromPairing(pairing: PairingTypes.Struct): string;\n}\n\nexport interface IPairingPrivate {\n  sendRequest<M extends PairingJsonRpcTypes.WcMethod>(\n    topic: string,\n    method: M,\n    params: PairingJsonRpcTypes.RequestParams[M],\n  ): Promise<number>;\n\n  sendResult<M extends PairingJsonRpcTypes.WcMethod>(\n    id: number,\n    topic: string,\n    result: PairingJsonRpcTypes.Results[M],\n  ): Promise<void>;\n\n  sendError(id: number, topic: string, error: PairingJsonRpcTypes.Error): Promise<void>;\n\n  onRelayEventRequest(event: PairingJsonRpcTypes.EventCallback<JsonRpcRequest>): Promise<void>;\n\n  onRelayEventResponse(event: PairingJsonRpcTypes.EventCallback<JsonRpcResponse>): Promise<void>;\n\n  onPairingPingRequest(\n    topic: string,\n    payload: JsonRpcRequest<PairingJsonRpcTypes.RequestParams[\"wc_pairingPing\"]>,\n  ): Promise<void>;\n\n  onPairingPingResponse(\n    topic: string,\n    payload: JsonRpcResult<PairingJsonRpcTypes.Results[\"wc_pairingPing\"]> | JsonRpcError,\n  ): void;\n\n  onPairingDeleteRequest(\n    topic: string,\n    payload: JsonRpcRequest<PairingJsonRpcTypes.RequestParams[\"wc_pairingDelete\"]>,\n  ): Promise<void>;\n\n  onUnknownRpcMethodRequest(topic: string, payload: JsonRpcRequest): Promise<void>;\n\n  onUnknownRpcMethodResponse(method: string): void;\n\n  deletePairing(topic: string, expirerHasDeleted?: boolean): Promise<void>;\n}\n","import { Logger } from \"@walletconnect/logger\";\nimport { IKeyValueStorage } from \"@walletconnect/keyvaluestorage\";\nimport { ICore } from \"./core\";\n\nexport declare namespace Verify {\n  export interface Context {\n    verified: {\n      origin: string;\n      validation: \"UNKNOWN\" | \"VALID\" | \"INVALID\";\n      verifyUrl: string;\n      isScam?: boolean;\n    };\n  }\n}\n\nexport abstract class IVerify {\n  public abstract readonly context: string;\n\n  constructor(\n    public core: ICore,\n    public logger: Logger,\n    public store: IKeyValueStorage,\n  ) {}\n\n  public abstract register(params: {\n    id: string;\n    decryptedId: string;\n  }): Promise<string | undefined>;\n\n  public abstract resolve(params: {\n    attestationId?: string;\n    hash?: string;\n    encryptedId?: string;\n    verifyUrl?: string;\n  }): Promise<{ origin: string; isScam?: boolean }>;\n}\n","import { Logger } from \"@walletconnect/logger\";\n\nexport declare namespace EchoClientTypes {\n  type RegisterDeviceTokenParams = {\n    clientId: string;\n    token: string;\n    notificationType: \"fcm\" | \"apns\" | \"apns-sandbox\" | \"noop\";\n    enableEncrypted?: boolean;\n  };\n}\nexport abstract class IEchoClient {\n  public abstract readonly context: string;\n  constructor(\n    public projectId: string,\n    public logger: Logger,\n  ) {}\n\n  public abstract registerDeviceToken(\n    params: EchoClientTypes.RegisterDeviceTokenParams,\n  ): Promise<void>;\n}\n","import { Logger } from \"@walletconnect/logger\";\nimport { ICore } from \"./core\";\n\nexport declare namespace EventClientTypes {\n  export interface Event {\n    eventId: string;\n    bundleId: string;\n    timestamp: number;\n    props: Props;\n    addTrace: (trace: string) => void;\n    setError: (error: string) => void;\n  }\n\n  export interface Props {\n    event: string;\n    type: string;\n    properties: Properties;\n  }\n\n  export interface Properties {\n    topic: string;\n    trace: Trace;\n  }\n\n  export type Trace = string[];\n}\n\nexport abstract class IEventClient {\n  public abstract readonly context: string;\n\n  constructor(\n    public core: ICore,\n    public logger: Logger,\n    public telemetryEnabled: boolean,\n  ) {}\n\n  public abstract init(): Promise<void>;\n\n  public abstract createEvent(params: {\n    event?: \"ERROR\";\n    type?: string;\n    properties: {\n      topic: string;\n      trace: EventClientTypes.Trace;\n    };\n  }): EventClientTypes.Event;\n\n  public abstract getEvent(params: {\n    eventId?: string;\n    topic?: string;\n  }): EventClientTypes.Event | undefined;\n\n  public abstract deleteEvent(params: { eventId: string }): void;\n}\n","import { Logger } from \"@walletconnect/logger\";\nimport EventEmmiter from \"events\";\nimport { CoreTypes, ICore } from \"../core/core\";\nimport { IEngine } from \"./engine\";\nimport { IPendingRequest } from \"./pendingRequest\";\nimport { IProposal, ProposalTypes } from \"./proposal\";\nimport { ISession, SessionTypes } from \"./session\";\nimport { Verify } from \"../core/verify\";\nimport { IAuth, AuthTypes } from \"./auth\";\nimport { RelayerTypes } from \"../core\";\n\nexport declare namespace SignClientTypes {\n  type Event =\n    | \"session_proposal\"\n    | \"session_update\"\n    | \"session_extend\"\n    | \"session_ping\"\n    | \"session_delete\"\n    | \"session_expire\"\n    | \"session_request\"\n    | \"session_request_sent\"\n    | \"session_event\"\n    | \"session_authenticate\"\n    | \"proposal_expire\"\n    | \"session_request_expire\"\n    | \"session_connect\";\n\n  interface BaseEventArgs<T = unknown> {\n    id: number;\n    topic: string;\n    params: T;\n  }\n  interface EventArguments {\n    session_proposal: {\n      verifyContext: Verify.Context;\n    } & Omit<BaseEventArgs<ProposalTypes.Struct>, \"topic\">;\n    session_update: BaseEventArgs<{ namespaces: SessionTypes.Namespaces }>;\n    session_extend: Omit<BaseEventArgs, \"params\">;\n    session_ping: Omit<BaseEventArgs, \"params\">;\n    session_delete: Omit<BaseEventArgs, \"params\">;\n    session_expire: { topic: string };\n    session_request: {\n      verifyContext: Verify.Context;\n    } & BaseEventArgs<{\n      request: { method: string; params: any; expiryTimestamp?: number };\n      chainId: string;\n    }>;\n    session_request_sent: {\n      request: { method: string; params: any };\n      topic: string;\n      chainId: string;\n      id: number;\n    };\n    session_event: BaseEventArgs<{\n      event: { name: string; data: any };\n      chainId: string;\n    }>;\n    session_authenticate: {\n      verifyContext: Verify.Context;\n      transportType?: RelayerTypes.TransportType;\n    } & BaseEventArgs<AuthTypes.AuthRequestEventArgs>;\n    proposal_expire: { id: number };\n    session_request_expire: { id: number };\n    session_connect: { session: SessionTypes.Struct };\n  }\n\n  type Metadata = CoreTypes.Metadata;\n\n  type SignConfig = {\n    disableRequestQueue?: boolean;\n  };\n\n  interface Options extends CoreTypes.Options {\n    core?: ICore;\n    metadata?: Metadata;\n    signConfig?: SignConfig;\n  }\n}\n\nexport abstract class ISignClientEvents extends EventEmmiter {\n  constructor() {\n    super();\n  }\n\n  public abstract emit: <E extends SignClientTypes.Event>(\n    event: E,\n    args: SignClientTypes.EventArguments[E],\n  ) => boolean;\n\n  public abstract on: <E extends SignClientTypes.Event>(\n    event: E,\n    listener: (args: SignClientTypes.EventArguments[E]) => any,\n  ) => this;\n\n  public abstract once: <E extends SignClientTypes.Event>(\n    event: E,\n    listener: (args: SignClientTypes.EventArguments[E]) => any,\n  ) => this;\n\n  public abstract off: <E extends SignClientTypes.Event>(\n    event: E,\n    listener: (args: SignClientTypes.EventArguments[E]) => any,\n  ) => this;\n\n  public abstract removeListener: <E extends SignClientTypes.Event>(\n    event: E,\n    listener: (args: SignClientTypes.EventArguments[E]) => any,\n  ) => this;\n\n  public abstract removeAllListeners: <E extends SignClientTypes.Event>(event: E) => this;\n}\n\nexport abstract class ISignClient {\n  public readonly protocol = \"wc\";\n  public readonly version = 2;\n\n  public abstract readonly name: string;\n  public abstract readonly context: string;\n  public abstract readonly metadata: SignClientTypes.Metadata;\n\n  public abstract core: ICore;\n  public abstract logger: Logger;\n  public abstract events: ISignClientEvents;\n  public abstract engine: IEngine;\n  public abstract session: ISession;\n  public abstract proposal: IProposal;\n  public abstract pendingRequest: IPendingRequest;\n  public abstract auth: IAuth;\n  public abstract signConfig?: SignClientTypes.SignConfig;\n\n  constructor(public opts?: SignClientTypes.Options) {}\n\n  public abstract connect: IEngine[\"connect\"];\n  public abstract pair: IEngine[\"pair\"];\n  public abstract approve: IEngine[\"approve\"];\n  public abstract reject: IEngine[\"reject\"];\n  public abstract update: IEngine[\"update\"];\n  public abstract extend: IEngine[\"extend\"];\n  public abstract request: IEngine[\"request\"];\n  public abstract respond: IEngine[\"respond\"];\n  public abstract ping: IEngine[\"ping\"];\n  public abstract emit: IEngine[\"emit\"];\n  public abstract disconnect: IEngine[\"disconnect\"];\n  public abstract find: IEngine[\"find\"];\n  public abstract getPendingSessionRequests: IEngine[\"getPendingSessionRequests\"];\n  public abstract authenticate: IEngine[\"authenticate\"];\n  public abstract formatAuthMessage: IEngine[\"formatAuthMessage\"];\n  public abstract approveSessionAuthenticate: IEngine[\"approveSessionAuthenticate\"];\n  public abstract rejectSessionAuthenticate: IEngine[\"rejectSessionAuthenticate\"];\n}\n","import {\n  JsonRpcResponse,\n  JsonRpcRequest,\n  ErrorResponse,\n  JsonRpcResult,\n  JsonRpcError,\n} from \"@walletconnect/jsonrpc-types\";\nimport { ISignClient } from \"./client\";\nimport { RelayerTypes } from \"../core/relayer\";\nimport { SessionTypes } from \"./session\";\nimport { ProposalTypes } from \"./proposal\";\nimport { PairingTypes } from \"../core/pairing\";\nimport { JsonRpcTypes } from \"./jsonrpc\";\nimport { EventEmitter } from \"events\";\nimport { PendingRequestTypes } from \"./pendingRequest\";\nimport { AuthTypes } from \"./auth\";\nimport { CryptoTypes } from \"../core\";\n\nexport declare namespace EngineTypes {\n  type Event =\n    | \"session_connect\"\n    | \"session_approve\"\n    | \"session_update\"\n    | \"session_extend\"\n    | \"session_ping\"\n    | \"pairing_ping\"\n    | \"session_request\";\n\n  interface EventArguments {\n    session_connect: {\n      error?: ErrorResponse;\n      session?: SessionTypes.Struct;\n    };\n    session_approve: { error?: ErrorResponse };\n    session_update: { error?: ErrorResponse };\n    session_extend: { error?: ErrorResponse };\n    session_ping: { error?: ErrorResponse };\n    pairing_ping: { error?: ErrorResponse };\n    session_request: { error?: ErrorResponse; result?: any };\n  }\n\n  interface UriParameters {\n    protocol: string;\n    version: number;\n    topic: string;\n    symKey: string;\n    relay: RelayerTypes.ProtocolOptions;\n    methods?: string[];\n    expiryTimestamp?: number;\n  }\n\n  interface EventCallback<T extends JsonRpcRequest | JsonRpcResponse> {\n    topic: string;\n    payload: T;\n    transportType?: RelayerTypes.MessageEvent[\"transportType\"];\n    attestation?: string;\n    encryptedId?: string;\n  }\n\n  interface ConnectParams {\n    /**\n     * @deprecated Use `optionalNamespaces` instead.\n     */\n    requiredNamespaces?: ProposalTypes.RequiredNamespaces;\n    optionalNamespaces?: ProposalTypes.OptionalNamespaces;\n    sessionProperties?: ProposalTypes.SessionProperties;\n    scopedProperties?: ProposalTypes.ScopedProperties;\n    pairingTopic?: string;\n    relays?: RelayerTypes.ProtocolOptions[];\n  }\n\n  interface PairParams {\n    uri: string;\n  }\n\n  interface ApproveParams {\n    id: number;\n    namespaces: SessionTypes.Namespaces;\n    sessionProperties?: ProposalTypes.SessionProperties;\n    scopedProperties?: ProposalTypes.ScopedProperties;\n    sessionConfig?: SessionTypes.SessionConfig;\n    relayProtocol?: string;\n  }\n\n  interface RejectParams {\n    id: number;\n    reason: ErrorResponse;\n  }\n\n  interface UpdateParams {\n    topic: string;\n    namespaces: SessionTypes.Namespaces;\n  }\n\n  interface ExtendParams {\n    topic: string;\n  }\n\n  interface RequestParams {\n    topic: string;\n    request: {\n      method: string;\n      params: any;\n    };\n    chainId: string;\n    expiry?: number;\n  }\n\n  interface RespondParams {\n    topic: string;\n    response: JsonRpcResponse;\n  }\n\n  interface EmitParams {\n    topic: string;\n    event: {\n      name: string;\n      data: any;\n    };\n    chainId: string;\n  }\n\n  interface PingParams {\n    topic: string;\n  }\n\n  interface DisconnectParams {\n    topic: string;\n    reason: ErrorResponse;\n  }\n\n  interface FindParams {\n    requiredNamespaces: ProposalTypes.RequiredNamespaces;\n  }\n\n  type AcknowledgedPromise = Promise<{ acknowledged: () => Promise<void> }>;\n\n  type SessionAuthenticateResponsePromise = {\n    uri: string;\n    response: () => Promise<AuthTypes.AuthenticateResponseResult>;\n  };\n\n  interface RpcOpts {\n    req: RelayerTypes.PublishOptions & {\n      ttl: number;\n    };\n    res: RelayerTypes.PublishOptions & {\n      ttl: number;\n    };\n    reject?: RelayerTypes.PublishOptions & {\n      ttl: number;\n    };\n    autoReject?: RelayerTypes.PublishOptions & {\n      ttl: number;\n    };\n  }\n\n  type RpcOptsMap = Record<JsonRpcTypes.WcMethod, RpcOpts>;\n\n  type EngineQueue<T> = {\n    state: \"IDLE\" | \"ACTIVE\";\n    queue: T[];\n  };\n}\n\nexport abstract class IEngineEvents extends EventEmitter {\n  constructor() {\n    super();\n  }\n\n  public abstract emit: <E extends EngineTypes.Event>(\n    event: string,\n    args: EngineTypes.EventArguments[E],\n  ) => boolean;\n\n  public abstract once: <E extends EngineTypes.Event>(\n    event: string,\n    listener: (args: EngineTypes.EventArguments[E]) => any,\n  ) => this;\n}\n\n// -- private method interface -------------------------------------- //\n\nexport interface EnginePrivate {\n  sendRequest<M extends JsonRpcTypes.WcMethod>(args: {\n    topic: string;\n    method: M;\n    params: JsonRpcTypes.RequestParams[M];\n    expiry?: number;\n    relayRpcId?: number;\n    clientRpcId?: number;\n    throwOnFailedPublish?: boolean;\n    appLink?: string;\n    tvf?: RelayerTypes.ITVF;\n  }): Promise<number>;\n\n  sendResult<M extends JsonRpcTypes.WcMethod>(args: {\n    id: number;\n    topic: string;\n    result: JsonRpcTypes.Results[M];\n    throwOnFailedPublish?: boolean;\n    encodeOpts?: CryptoTypes.EncodeOptions;\n    appLink?: string;\n  }): Promise<void>;\n\n  sendError(params: {\n    id: number;\n    topic: string;\n    error: JsonRpcTypes.Error;\n    encodeOpts?: CryptoTypes.EncodeOptions;\n    rpcOpts?: RelayerTypes.PublishOptions;\n    appLink?: string;\n  }): Promise<void>;\n\n  onRelayEventRequest(event: EngineTypes.EventCallback<JsonRpcRequest>): Promise<void>;\n\n  onRelayEventResponse(event: EngineTypes.EventCallback<JsonRpcResponse>): Promise<void>;\n\n  onRelayEventUnknownPayload(event: EngineTypes.EventCallback<any>): Promise<void>;\n\n  shouldIgnorePairingRequest(params: { topic: string; requestMethod: string }): boolean;\n\n  deleteSession(params: {\n    topic: string;\n    expirerHasDeleted?: boolean;\n    id?: number;\n    emitEvent?: boolean;\n  }): Promise<void>;\n\n  deleteProposal(id: number, expirerHasDeleted?: boolean): Promise<void>;\n\n  setExpiry(topic: string, expiry: number): Promise<void>;\n\n  setProposal(id: number, proposal: ProposalTypes.Struct): Promise<void>;\n\n  setAuthRequest(\n    id: number,\n    params: {\n      request: AuthTypes.SessionAuthenticateRequest;\n      pairingTopic: string;\n      transportType?: RelayerTypes.MessageEvent[\"transportType\"];\n    },\n  ): Promise<void>;\n\n  setPendingSessionRequest(pendingRequest: PendingRequestTypes.Struct): Promise<void>;\n\n  deletePendingSessionRequest(\n    id: number,\n    reason: ErrorResponse,\n    expirerHasDeleted?: boolean,\n  ): Promise<void>;\n\n  deletePendingAuthRequest(\n    id: number,\n    reason: ErrorResponse,\n    expirerHasDeleted?: boolean,\n  ): Promise<void>;\n\n  cleanupDuplicatePairings(session: SessionTypes.Struct): Promise<void>;\n\n  cleanup(): Promise<void>;\n\n  onSessionProposeRequest(params: {\n    topic: string;\n    payload: JsonRpcRequest<JsonRpcTypes.RequestParams[\"wc_sessionPropose\"]>;\n    attestation?: string;\n    encryptedId?: string;\n  }): Promise<void>;\n\n  onSessionProposeResponse(\n    topic: string,\n    payload: JsonRpcResult<JsonRpcTypes.Results[\"wc_sessionPropose\"]> | JsonRpcError,\n    transportType?: RelayerTypes.MessageEvent[\"transportType\"],\n  ): Promise<void>;\n\n  onSessionSettleRequest(\n    topic: string,\n    payload: JsonRpcRequest<JsonRpcTypes.RequestParams[\"wc_sessionSettle\"]>,\n  ): Promise<void>;\n\n  onSessionSettleResponse(\n    topic: string,\n    payload: JsonRpcResult<JsonRpcTypes.Results[\"wc_sessionSettle\"]> | JsonRpcError,\n  ): Promise<void>;\n\n  onSessionUpdateRequest(\n    topic: string,\n    payload: JsonRpcRequest<JsonRpcTypes.RequestParams[\"wc_sessionUpdate\"]>,\n  ): Promise<void>;\n\n  onSessionUpdateResponse(\n    topic: string,\n    payload: JsonRpcResult<JsonRpcTypes.Results[\"wc_sessionUpdate\"]> | JsonRpcError,\n  ): void;\n\n  onSessionExtendRequest(\n    topic: string,\n    payload: JsonRpcRequest<JsonRpcTypes.RequestParams[\"wc_sessionExtend\"]>,\n  ): Promise<void>;\n\n  onSessionExtendResponse(\n    topic: string,\n    payload: JsonRpcResult<JsonRpcTypes.Results[\"wc_sessionExtend\"]> | JsonRpcError,\n  ): void;\n\n  onSessionPingRequest(\n    topic: string,\n    payload: JsonRpcRequest<JsonRpcTypes.RequestParams[\"wc_sessionPing\"]>,\n  ): Promise<void>;\n\n  onSessionPingResponse(\n    topic: string,\n    payload: JsonRpcResult<JsonRpcTypes.Results[\"wc_sessionPing\"]> | JsonRpcError,\n  ): void;\n\n  onSessionDeleteRequest(\n    topic: string,\n    payload: JsonRpcRequest<JsonRpcTypes.RequestParams[\"wc_sessionDelete\"]>,\n  ): Promise<void>;\n\n  onSessionRequest(params: {\n    topic: string;\n    payload: JsonRpcRequest<JsonRpcTypes.RequestParams[\"wc_sessionRequest\"]>;\n    transportType?: RelayerTypes.MessageEvent[\"transportType\"];\n    attestation?: string;\n    encryptedId?: string;\n  }): Promise<void>;\n\n  onSessionRequestResponse(\n    topic: string,\n    payload: JsonRpcResult<JsonRpcTypes.Results[\"wc_sessionRequest\"]> | JsonRpcError,\n  ): void;\n\n  onSessionEventRequest(\n    topic: string,\n    payload: JsonRpcRequest<JsonRpcTypes.RequestParams[\"wc_sessionEvent\"]>,\n  ): Promise<void>;\n\n  onSessionAuthenticateRequest(params: {\n    topic: string;\n    payload: JsonRpcRequest<JsonRpcTypes.RequestParams[\"wc_sessionAuthenticate\"]>;\n    transportType?: RelayerTypes.MessageEvent[\"transportType\"];\n    attestation?: string;\n    encryptedId?: string;\n  }): Promise<void>;\n\n  onSessionAuthenticateResponse(\n    topic: string,\n    payload: JsonRpcResult<JsonRpcTypes.Results[\"wc_sessionAuthenticate\"]> | JsonRpcError,\n  ): void;\n\n  // -- Validators ---------------------------------------------------- //\n  isValidConnect(params: EngineTypes.ConnectParams): Promise<void>;\n\n  isValidSessionSettleRequest(params: JsonRpcTypes.RequestParams[\"wc_sessionSettle\"]): void;\n\n  isValidApprove(params: EngineTypes.ApproveParams): Promise<void>;\n\n  isValidReject(params: EngineTypes.RejectParams): Promise<void>;\n\n  isValidUpdate(params: EngineTypes.UpdateParams): Promise<void>;\n\n  isValidExtend(params: EngineTypes.ExtendParams): Promise<void>;\n\n  isValidRequest(params: EngineTypes.RequestParams): Promise<void>;\n\n  isValidRespond(params: EngineTypes.RespondParams): Promise<void>;\n\n  isValidPing(params: EngineTypes.PingParams): Promise<void>;\n\n  isValidEmit(params: EngineTypes.EmitParams): Promise<void>;\n\n  isValidDisconnect(params: EngineTypes.DisconnectParams): Promise<void>;\n}\n\n// -- class interface ----------------------------------------------- //\n\nexport abstract class IEngine {\n  constructor(public client: ISignClient) {}\n\n  public abstract init(): Promise<void>;\n\n  public abstract connect(\n    params: EngineTypes.ConnectParams,\n  ): Promise<{ uri?: string; approval: () => Promise<SessionTypes.Struct> }>;\n\n  public abstract pair(params: EngineTypes.PairParams): Promise<PairingTypes.Struct>;\n\n  public abstract approve(\n    params: EngineTypes.ApproveParams,\n  ): Promise<{ topic: string; acknowledged: () => Promise<SessionTypes.Struct> }>;\n\n  public abstract reject(params: EngineTypes.RejectParams): Promise<void>;\n\n  public abstract update(params: EngineTypes.UpdateParams): EngineTypes.AcknowledgedPromise;\n\n  public abstract extend(params: EngineTypes.ExtendParams): EngineTypes.AcknowledgedPromise;\n\n  public abstract request<T>(params: EngineTypes.RequestParams): Promise<T>;\n\n  public abstract respond(params: EngineTypes.RespondParams): Promise<void>;\n\n  public abstract emit(params: EngineTypes.EmitParams): Promise<void>;\n\n  public abstract ping(params: EngineTypes.PingParams): Promise<void>;\n\n  public abstract disconnect(params: EngineTypes.DisconnectParams): Promise<void>;\n\n  public abstract find: (params: EngineTypes.FindParams) => SessionTypes.Struct[];\n\n  public abstract getPendingSessionRequests: () => PendingRequestTypes.Struct[];\n\n  public abstract authenticate: (\n    params: AuthTypes.SessionAuthenticateParams,\n    walletUniversalLink?: string,\n  ) => Promise<EngineTypes.SessionAuthenticateResponsePromise>;\n\n  public abstract approveSessionAuthenticate: (\n    params: AuthTypes.ApproveSessionAuthenticateParams,\n  ) => Promise<{ session: SessionTypes.Struct | undefined }>;\n\n  public abstract formatAuthMessage: (params: {\n    request: AuthTypes.BaseAuthRequestParams;\n    iss: string;\n  }) => string;\n\n  public abstract rejectSessionAuthenticate(params: EngineTypes.RejectParams): Promise<void>;\n\n  public abstract processRelayMessageCache(): void;\n}\n"],"names":["IEvents","opts","__publicField","core","logger","keychain","relayer","name","storagePrefix","store","projectId","telemetryEnabled","EventEmmiter","EventEmitter","client"],"mappings":"","ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15],"debugId":null}},
    {"offset": {"line": 160, "column": 0}, "map": {"version":3,"file":"index.es.js","sources":["file:///Users/alex/code/Personal_Projects/web3-social-app/node_modules/.pnpm/%40walletconnect%2Buniversal-provider%402.21.0_bufferutil%404.0.9_typescript%405.8.3_utf-8-validate%405.0.10_zod%403.22.4/node_modules/%40walletconnect/universal-provider/src/constants/values.ts","file:///Users/alex/code/Personal_Projects/web3-social-app/node_modules/.pnpm/%40walletconnect%2Buniversal-provider%402.21.0_bufferutil%404.0.9_typescript%405.8.3_utf-8-validate%405.0.10_zod%403.22.4/node_modules/%40walletconnect/universal-provider/src/constants/events.ts","file:///Users/alex/code/Personal_Projects/web3-social-app/node_modules/.pnpm/%40walletconnect%2Buniversal-provider%402.21.0_bufferutil%404.0.9_typescript%405.8.3_utf-8-validate%405.0.10_zod%403.22.4/node_modules/node_modules/es-toolkit/dist/function/noop.mjs","file:///Users/alex/code/Personal_Projects/web3-social-app/node_modules/.pnpm/%40walletconnect%2Buniversal-provider%402.21.0_bufferutil%404.0.9_typescript%405.8.3_utf-8-validate%405.0.10_zod%403.22.4/node_modules/node_modules/es-toolkit/dist/predicate/isPrimitive.mjs","file:///Users/alex/code/Personal_Projects/web3-social-app/node_modules/.pnpm/%40walletconnect%2Buniversal-provider%402.21.0_bufferutil%404.0.9_typescript%405.8.3_utf-8-validate%405.0.10_zod%403.22.4/node_modules/node_modules/es-toolkit/dist/predicate/isTypedArray.mjs","file:///Users/alex/code/Personal_Projects/web3-social-app/node_modules/.pnpm/%40walletconnect%2Buniversal-provider%402.21.0_bufferutil%404.0.9_typescript%405.8.3_utf-8-validate%405.0.10_zod%403.22.4/node_modules/node_modules/es-toolkit/dist/object/clone.mjs","file:///Users/alex/code/Personal_Projects/web3-social-app/node_modules/.pnpm/%40walletconnect%2Buniversal-provider%402.21.0_bufferutil%404.0.9_typescript%405.8.3_utf-8-validate%405.0.10_zod%403.22.4/node_modules/node_modules/es-toolkit/dist/compat/predicate/isObjectLike.mjs","file:///Users/alex/code/Personal_Projects/web3-social-app/node_modules/.pnpm/%40walletconnect%2Buniversal-provider%402.21.0_bufferutil%404.0.9_typescript%405.8.3_utf-8-validate%405.0.10_zod%403.22.4/node_modules/node_modules/es-toolkit/dist/compat/_internal/getSymbols.mjs","file:///Users/alex/code/Personal_Projects/web3-social-app/node_modules/.pnpm/%40walletconnect%2Buniversal-provider%402.21.0_bufferutil%404.0.9_typescript%405.8.3_utf-8-validate%405.0.10_zod%403.22.4/node_modules/node_modules/es-toolkit/dist/compat/_internal/getTag.mjs","file:///Users/alex/code/Personal_Projects/web3-social-app/node_modules/.pnpm/%40walletconnect%2Buniversal-provider%402.21.0_bufferutil%404.0.9_typescript%405.8.3_utf-8-validate%405.0.10_zod%403.22.4/node_modules/node_modules/es-toolkit/dist/compat/_internal/tags.mjs","file:///Users/alex/code/Personal_Projects/web3-social-app/node_modules/.pnpm/%40walletconnect%2Buniversal-provider%402.21.0_bufferutil%404.0.9_typescript%405.8.3_utf-8-validate%405.0.10_zod%403.22.4/node_modules/node_modules/es-toolkit/dist/object/cloneDeepWith.mjs","file:///Users/alex/code/Personal_Projects/web3-social-app/node_modules/.pnpm/%40walletconnect%2Buniversal-provider%402.21.0_bufferutil%404.0.9_typescript%405.8.3_utf-8-validate%405.0.10_zod%403.22.4/node_modules/node_modules/es-toolkit/dist/compat/object/cloneDeepWith.mjs","file:///Users/alex/code/Personal_Projects/web3-social-app/node_modules/.pnpm/%40walletconnect%2Buniversal-provider%402.21.0_bufferutil%404.0.9_typescript%405.8.3_utf-8-validate%405.0.10_zod%403.22.4/node_modules/node_modules/es-toolkit/dist/compat/object/cloneDeep.mjs","file:///Users/alex/code/Personal_Projects/web3-social-app/node_modules/.pnpm/%40walletconnect%2Buniversal-provider%402.21.0_bufferutil%404.0.9_typescript%405.8.3_utf-8-validate%405.0.10_zod%403.22.4/node_modules/node_modules/es-toolkit/dist/compat/predicate/isArguments.mjs","file:///Users/alex/code/Personal_Projects/web3-social-app/node_modules/.pnpm/%40walletconnect%2Buniversal-provider%402.21.0_bufferutil%404.0.9_typescript%405.8.3_utf-8-validate%405.0.10_zod%403.22.4/node_modules/node_modules/es-toolkit/dist/compat/predicate/isTypedArray.mjs","file:///Users/alex/code/Personal_Projects/web3-social-app/node_modules/.pnpm/%40walletconnect%2Buniversal-provider%402.21.0_bufferutil%404.0.9_typescript%405.8.3_utf-8-validate%405.0.10_zod%403.22.4/node_modules/node_modules/es-toolkit/dist/compat/predicate/isPlainObject.mjs","file:///Users/alex/code/Personal_Projects/web3-social-app/node_modules/.pnpm/%40walletconnect%2Buniversal-provider%402.21.0_bufferutil%404.0.9_typescript%405.8.3_utf-8-validate%405.0.10_zod%403.22.4/node_modules/node_modules/es-toolkit/dist/compat/object/mergeWith.mjs","file:///Users/alex/code/Personal_Projects/web3-social-app/node_modules/.pnpm/%40walletconnect%2Buniversal-provider%402.21.0_bufferutil%404.0.9_typescript%405.8.3_utf-8-validate%405.0.10_zod%403.22.4/node_modules/node_modules/es-toolkit/dist/compat/object/merge.mjs","file:///Users/alex/code/Personal_Projects/web3-social-app/node_modules/.pnpm/%40walletconnect%2Buniversal-provider%402.21.0_bufferutil%404.0.9_typescript%405.8.3_utf-8-validate%405.0.10_zod%403.22.4/node_modules/%40walletconnect/universal-provider/src/utils/misc.ts","file:///Users/alex/code/Personal_Projects/web3-social-app/node_modules/.pnpm/%40walletconnect%2Buniversal-provider%402.21.0_bufferutil%404.0.9_typescript%405.8.3_utf-8-validate%405.0.10_zod%403.22.4/node_modules/%40walletconnect/universal-provider/src/utils/globals.ts","file:///Users/alex/code/Personal_Projects/web3-social-app/node_modules/.pnpm/%40walletconnect%2Buniversal-provider%402.21.0_bufferutil%404.0.9_typescript%405.8.3_utf-8-validate%405.0.10_zod%403.22.4/node_modules/%40walletconnect/universal-provider/src/providers/polkadot.ts","file:///Users/alex/code/Personal_Projects/web3-social-app/node_modules/.pnpm/%40walletconnect%2Buniversal-provider%402.21.0_bufferutil%404.0.9_typescript%405.8.3_utf-8-validate%405.0.10_zod%403.22.4/node_modules/%40walletconnect/universal-provider/src/providers/eip155.ts","file:///Users/alex/code/Personal_Projects/web3-social-app/node_modules/.pnpm/%40walletconnect%2Buniversal-provider%402.21.0_bufferutil%404.0.9_typescript%405.8.3_utf-8-validate%405.0.10_zod%403.22.4/node_modules/%40walletconnect/universal-provider/src/providers/solana.ts","file:///Users/alex/code/Personal_Projects/web3-social-app/node_modules/.pnpm/%40walletconnect%2Buniversal-provider%402.21.0_bufferutil%404.0.9_typescript%405.8.3_utf-8-validate%405.0.10_zod%403.22.4/node_modules/%40walletconnect/universal-provider/src/providers/cosmos.ts","file:///Users/alex/code/Personal_Projects/web3-social-app/node_modules/.pnpm/%40walletconnect%2Buniversal-provider%402.21.0_bufferutil%404.0.9_typescript%405.8.3_utf-8-validate%405.0.10_zod%403.22.4/node_modules/%40walletconnect/universal-provider/src/providers/algorand.ts","file:///Users/alex/code/Personal_Projects/web3-social-app/node_modules/.pnpm/%40walletconnect%2Buniversal-provider%402.21.0_bufferutil%404.0.9_typescript%405.8.3_utf-8-validate%405.0.10_zod%403.22.4/node_modules/%40walletconnect/universal-provider/src/providers/cardano.ts","file:///Users/alex/code/Personal_Projects/web3-social-app/node_modules/.pnpm/%40walletconnect%2Buniversal-provider%402.21.0_bufferutil%404.0.9_typescript%405.8.3_utf-8-validate%405.0.10_zod%403.22.4/node_modules/%40walletconnect/universal-provider/src/providers/elrond.ts","file:///Users/alex/code/Personal_Projects/web3-social-app/node_modules/.pnpm/%40walletconnect%2Buniversal-provider%402.21.0_bufferutil%404.0.9_typescript%405.8.3_utf-8-validate%405.0.10_zod%403.22.4/node_modules/%40walletconnect/universal-provider/src/providers/multiversx.ts","file:///Users/alex/code/Personal_Projects/web3-social-app/node_modules/.pnpm/%40walletconnect%2Buniversal-provider%402.21.0_bufferutil%404.0.9_typescript%405.8.3_utf-8-validate%405.0.10_zod%403.22.4/node_modules/%40walletconnect/universal-provider/src/providers/near.ts","file:///Users/alex/code/Personal_Projects/web3-social-app/node_modules/.pnpm/%40walletconnect%2Buniversal-provider%402.21.0_bufferutil%404.0.9_typescript%405.8.3_utf-8-validate%405.0.10_zod%403.22.4/node_modules/%40walletconnect/universal-provider/src/providers/tezos.ts","file:///Users/alex/code/Personal_Projects/web3-social-app/node_modules/.pnpm/%40walletconnect%2Buniversal-provider%402.21.0_bufferutil%404.0.9_typescript%405.8.3_utf-8-validate%405.0.10_zod%403.22.4/node_modules/%40walletconnect/universal-provider/src/providers/generic.ts","file:///Users/alex/code/Personal_Projects/web3-social-app/node_modules/.pnpm/%40walletconnect%2Buniversal-provider%402.21.0_bufferutil%404.0.9_typescript%405.8.3_utf-8-validate%405.0.10_zod%403.22.4/node_modules/%40walletconnect/universal-provider/src/UniversalProvider.ts","file:///Users/alex/code/Personal_Projects/web3-social-app/node_modules/.pnpm/%40walletconnect%2Buniversal-provider%402.21.0_bufferutil%404.0.9_typescript%405.8.3_utf-8-validate%405.0.10_zod%403.22.4/node_modules/%40walletconnect/universal-provider/src/index.ts"],"sourcesContent":["export const LOGGER = \"error\";\n\nexport const RELAY_URL = \"wss://relay.walletconnect.org\";\n\nexport const PROTOCOL = \"wc\";\nexport const WC_VERSION = 2;\nexport const CONTEXT = \"universal_provider\";\n\nexport const STORAGE = `${PROTOCOL}@${WC_VERSION}:${CONTEXT}:`;\n\nexport const RPC_URL = \"https://rpc.walletconnect.org/v1/\";\n\nexport const GENERIC_SUBPROVIDER_NAME = \"generic\";\n\nexport const BUNDLER_URL = `${RPC_URL}bundler`;\n","export const PROVIDER_EVENTS = {\n  DEFAULT_CHAIN_CHANGED: \"default_chain_changed\",\n};\n","function noop() { }\n\nexport { noop };\n","function isPrimitive(value) {\n    return value == null || (typeof value !== 'object' && typeof value !== 'function');\n}\n\nexport { isPrimitive };\n","function isTypedArray(x) {\n    return ArrayBuffer.isView(x) && !(x instanceof DataView);\n}\n\nexport { isTypedArray };\n","import { isPrimitive } from '../predicate/isPrimitive.mjs';\nimport { isTypedArray } from '../predicate/isTypedArray.mjs';\n\nfunction clone(obj) {\n    if (isPrimitive(obj)) {\n        return obj;\n    }\n    if (Array.isArray(obj) ||\n        isTypedArray(obj) ||\n        obj instanceof ArrayBuffer ||\n        (typeof SharedArrayBuffer !== 'undefined' && obj instanceof SharedArrayBuffer)) {\n        return obj.slice(0);\n    }\n    const prototype = Object.getPrototypeOf(obj);\n    const Constructor = prototype.constructor;\n    if (obj instanceof Date || obj instanceof Map || obj instanceof Set) {\n        return new Constructor(obj);\n    }\n    if (obj instanceof RegExp) {\n        const newRegExp = new Constructor(obj);\n        newRegExp.lastIndex = obj.lastIndex;\n        return newRegExp;\n    }\n    if (obj instanceof DataView) {\n        return new Constructor(obj.buffer.slice(0));\n    }\n    if (obj instanceof Error) {\n        const newError = new Constructor(obj.message);\n        newError.stack = obj.stack;\n        newError.name = obj.name;\n        newError.cause = obj.cause;\n        return newError;\n    }\n    if (typeof File !== 'undefined' && obj instanceof File) {\n        const newFile = new Constructor([obj], obj.name, { type: obj.type, lastModified: obj.lastModified });\n        return newFile;\n    }\n    if (typeof obj === 'object') {\n        const newObject = Object.create(prototype);\n        return Object.assign(newObject, obj);\n    }\n    return obj;\n}\n\nexport { clone };\n","function isObjectLike(value) {\n    return typeof value === 'object' && value !== null;\n}\n\nexport { isObjectLike };\n","function getSymbols(object) {\n    return Object.getOwnPropertySymbols(object).filter(symbol => Object.prototype.propertyIsEnumerable.call(object, symbol));\n}\n\nexport { getSymbols };\n","function getTag(value) {\n    if (value == null) {\n        return value === undefined ? '[object Undefined]' : '[object Null]';\n    }\n    return Object.prototype.toString.call(value);\n}\n\nexport { getTag };\n","const regexpTag = '[object RegExp]';\nconst stringTag = '[object String]';\nconst numberTag = '[object Number]';\nconst booleanTag = '[object Boolean]';\nconst argumentsTag = '[object Arguments]';\nconst symbolTag = '[object Symbol]';\nconst dateTag = '[object Date]';\nconst mapTag = '[object Map]';\nconst setTag = '[object Set]';\nconst arrayTag = '[object Array]';\nconst functionTag = '[object Function]';\nconst arrayBufferTag = '[object ArrayBuffer]';\nconst objectTag = '[object Object]';\nconst errorTag = '[object Error]';\nconst dataViewTag = '[object DataView]';\nconst uint8ArrayTag = '[object Uint8Array]';\nconst uint8ClampedArrayTag = '[object Uint8ClampedArray]';\nconst uint16ArrayTag = '[object Uint16Array]';\nconst uint32ArrayTag = '[object Uint32Array]';\nconst bigUint64ArrayTag = '[object BigUint64Array]';\nconst int8ArrayTag = '[object Int8Array]';\nconst int16ArrayTag = '[object Int16Array]';\nconst int32ArrayTag = '[object Int32Array]';\nconst bigInt64ArrayTag = '[object BigInt64Array]';\nconst float32ArrayTag = '[object Float32Array]';\nconst float64ArrayTag = '[object Float64Array]';\n\nexport { argumentsTag, arrayBufferTag, arrayTag, bigInt64ArrayTag, bigUint64ArrayTag, booleanTag, dataViewTag, dateTag, errorTag, float32ArrayTag, float64ArrayTag, functionTag, int16ArrayTag, int32ArrayTag, int8ArrayTag, mapTag, numberTag, objectTag, regexpTag, setTag, stringTag, symbolTag, uint16ArrayTag, uint32ArrayTag, uint8ArrayTag, uint8ClampedArrayTag };\n","import { getSymbols } from '../compat/_internal/getSymbols.mjs';\nimport { getTag } from '../compat/_internal/getTag.mjs';\nimport { uint32ArrayTag, uint16ArrayTag, uint8ClampedArrayTag, uint8ArrayTag, symbolTag, stringTag, setTag, regexpTag, objectTag, numberTag, mapTag, int32ArrayTag, int16ArrayTag, int8ArrayTag, float64ArrayTag, float32ArrayTag, dateTag, booleanTag, dataViewTag, arrayBufferTag, arrayTag, argumentsTag } from '../compat/_internal/tags.mjs';\nimport { isPrimitive } from '../predicate/isPrimitive.mjs';\nimport { isTypedArray } from '../predicate/isTypedArray.mjs';\n\nfunction cloneDeepWith(obj, cloneValue) {\n    return cloneDeepWithImpl(obj, undefined, obj, new Map(), cloneValue);\n}\nfunction cloneDeepWithImpl(valueToClone, keyToClone, objectToClone, stack = new Map(), cloneValue = undefined) {\n    const cloned = cloneValue?.(valueToClone, keyToClone, objectToClone, stack);\n    if (cloned != null) {\n        return cloned;\n    }\n    if (isPrimitive(valueToClone)) {\n        return valueToClone;\n    }\n    if (stack.has(valueToClone)) {\n        return stack.get(valueToClone);\n    }\n    if (Array.isArray(valueToClone)) {\n        const result = new Array(valueToClone.length);\n        stack.set(valueToClone, result);\n        for (let i = 0; i < valueToClone.length; i++) {\n            result[i] = cloneDeepWithImpl(valueToClone[i], i, objectToClone, stack, cloneValue);\n        }\n        if (Object.hasOwn(valueToClone, 'index')) {\n            result.index = valueToClone.index;\n        }\n        if (Object.hasOwn(valueToClone, 'input')) {\n            result.input = valueToClone.input;\n        }\n        return result;\n    }\n    if (valueToClone instanceof Date) {\n        return new Date(valueToClone.getTime());\n    }\n    if (valueToClone instanceof RegExp) {\n        const result = new RegExp(valueToClone.source, valueToClone.flags);\n        result.lastIndex = valueToClone.lastIndex;\n        return result;\n    }\n    if (valueToClone instanceof Map) {\n        const result = new Map();\n        stack.set(valueToClone, result);\n        for (const [key, value] of valueToClone) {\n            result.set(key, cloneDeepWithImpl(value, key, objectToClone, stack, cloneValue));\n        }\n        return result;\n    }\n    if (valueToClone instanceof Set) {\n        const result = new Set();\n        stack.set(valueToClone, result);\n        for (const value of valueToClone) {\n            result.add(cloneDeepWithImpl(value, undefined, objectToClone, stack, cloneValue));\n        }\n        return result;\n    }\n    if (typeof Buffer !== 'undefined' && Buffer.isBuffer(valueToClone)) {\n        return valueToClone.subarray();\n    }\n    if (isTypedArray(valueToClone)) {\n        const result = new (Object.getPrototypeOf(valueToClone).constructor)(valueToClone.length);\n        stack.set(valueToClone, result);\n        for (let i = 0; i < valueToClone.length; i++) {\n            result[i] = cloneDeepWithImpl(valueToClone[i], i, objectToClone, stack, cloneValue);\n        }\n        return result;\n    }\n    if (valueToClone instanceof ArrayBuffer ||\n        (typeof SharedArrayBuffer !== 'undefined' && valueToClone instanceof SharedArrayBuffer)) {\n        return valueToClone.slice(0);\n    }\n    if (valueToClone instanceof DataView) {\n        const result = new DataView(valueToClone.buffer.slice(0), valueToClone.byteOffset, valueToClone.byteLength);\n        stack.set(valueToClone, result);\n        copyProperties(result, valueToClone, objectToClone, stack, cloneValue);\n        return result;\n    }\n    if (typeof File !== 'undefined' && valueToClone instanceof File) {\n        const result = new File([valueToClone], valueToClone.name, {\n            type: valueToClone.type,\n        });\n        stack.set(valueToClone, result);\n        copyProperties(result, valueToClone, objectToClone, stack, cloneValue);\n        return result;\n    }\n    if (valueToClone instanceof Blob) {\n        const result = new Blob([valueToClone], { type: valueToClone.type });\n        stack.set(valueToClone, result);\n        copyProperties(result, valueToClone, objectToClone, stack, cloneValue);\n        return result;\n    }\n    if (valueToClone instanceof Error) {\n        const result = new valueToClone.constructor();\n        stack.set(valueToClone, result);\n        result.message = valueToClone.message;\n        result.name = valueToClone.name;\n        result.stack = valueToClone.stack;\n        result.cause = valueToClone.cause;\n        copyProperties(result, valueToClone, objectToClone, stack, cloneValue);\n        return result;\n    }\n    if (typeof valueToClone === 'object' && isCloneableObject(valueToClone)) {\n        const result = Object.create(Object.getPrototypeOf(valueToClone));\n        stack.set(valueToClone, result);\n        copyProperties(result, valueToClone, objectToClone, stack, cloneValue);\n        return result;\n    }\n    return valueToClone;\n}\nfunction copyProperties(target, source, objectToClone = target, stack, cloneValue) {\n    const keys = [...Object.keys(source), ...getSymbols(source)];\n    for (let i = 0; i < keys.length; i++) {\n        const key = keys[i];\n        const descriptor = Object.getOwnPropertyDescriptor(target, key);\n        if (descriptor == null || descriptor.writable) {\n            target[key] = cloneDeepWithImpl(source[key], key, objectToClone, stack, cloneValue);\n        }\n    }\n}\nfunction isCloneableObject(object) {\n    switch (getTag(object)) {\n        case argumentsTag:\n        case arrayTag:\n        case arrayBufferTag:\n        case dataViewTag:\n        case booleanTag:\n        case dateTag:\n        case float32ArrayTag:\n        case float64ArrayTag:\n        case int8ArrayTag:\n        case int16ArrayTag:\n        case int32ArrayTag:\n        case mapTag:\n        case numberTag:\n        case objectTag:\n        case regexpTag:\n        case setTag:\n        case stringTag:\n        case symbolTag:\n        case uint8ArrayTag:\n        case uint8ClampedArrayTag:\n        case uint16ArrayTag:\n        case uint32ArrayTag: {\n            return true;\n        }\n        default: {\n            return false;\n        }\n    }\n}\n\nexport { cloneDeepWith, cloneDeepWithImpl, copyProperties };\n","import { cloneDeepWith as cloneDeepWith$1, copyProperties } from '../../object/cloneDeepWith.mjs';\nimport { argumentsTag, booleanTag, stringTag, numberTag } from '../_internal/tags.mjs';\n\nfunction cloneDeepWith(obj, cloneValue) {\n    return cloneDeepWith$1(obj, (value, key, object, stack) => {\n        const cloned = cloneValue?.(value, key, object, stack);\n        if (cloned != null) {\n            return cloned;\n        }\n        if (typeof obj !== 'object') {\n            return undefined;\n        }\n        switch (Object.prototype.toString.call(obj)) {\n            case numberTag:\n            case stringTag:\n            case booleanTag: {\n                const result = new obj.constructor(obj?.valueOf());\n                copyProperties(result, obj);\n                return result;\n            }\n            case argumentsTag: {\n                const result = {};\n                copyProperties(result, obj);\n                result.length = obj.length;\n                result[Symbol.iterator] = obj[Symbol.iterator];\n                return result;\n            }\n            default: {\n                return undefined;\n            }\n        }\n    });\n}\n\nexport { cloneDeepWith };\n","import { cloneDeepWith } from './cloneDeepWith.mjs';\n\nfunction cloneDeep(obj) {\n    return cloneDeepWith(obj);\n}\n\nexport { cloneDeep };\n","import { getTag } from '../_internal/getTag.mjs';\n\nfunction isArguments(value) {\n    return value !== null && typeof value === 'object' && getTag(value) === '[object Arguments]';\n}\n\nexport { isArguments };\n","import { isTypedArray as isTypedArray$1 } from '../../predicate/isTypedArray.mjs';\n\nfunction isTypedArray(x) {\n    return isTypedArray$1(x);\n}\n\nexport { isTypedArray };\n","function isPlainObject(object) {\n    if (typeof object !== 'object') {\n        return false;\n    }\n    if (object == null) {\n        return false;\n    }\n    if (Object.getPrototypeOf(object) === null) {\n        return true;\n    }\n    if (Object.prototype.toString.call(object) !== '[object Object]') {\n        const tag = object[Symbol.toStringTag];\n        if (tag == null) {\n            return false;\n        }\n        const isTagReadonly = !Object.getOwnPropertyDescriptor(object, Symbol.toStringTag)?.writable;\n        if (isTagReadonly) {\n            return false;\n        }\n        return object.toString() === `[object ${tag}]`;\n    }\n    let proto = object;\n    while (Object.getPrototypeOf(proto) !== null) {\n        proto = Object.getPrototypeOf(proto);\n    }\n    return Object.getPrototypeOf(object) === proto;\n}\n\nexport { isPlainObject };\n","import { cloneDeep } from './cloneDeep.mjs';\nimport { clone } from '../../object/clone.mjs';\nimport { isPrimitive } from '../../predicate/isPrimitive.mjs';\nimport { getSymbols } from '../_internal/getSymbols.mjs';\nimport { isArguments } from '../predicate/isArguments.mjs';\nimport { isObjectLike } from '../predicate/isObjectLike.mjs';\nimport { isPlainObject } from '../predicate/isPlainObject.mjs';\nimport { isTypedArray } from '../predicate/isTypedArray.mjs';\n\nfunction mergeWith(object, ...otherArgs) {\n    const sources = otherArgs.slice(0, -1);\n    const merge = otherArgs[otherArgs.length - 1];\n    let result = object;\n    for (let i = 0; i < sources.length; i++) {\n        const source = sources[i];\n        result = mergeWithDeep(result, source, merge, new Map());\n    }\n    return result;\n}\nfunction mergeWithDeep(target, source, merge, stack) {\n    if (isPrimitive(target)) {\n        target = Object(target);\n    }\n    if (source == null || typeof source !== 'object') {\n        return target;\n    }\n    if (stack.has(source)) {\n        return clone(stack.get(source));\n    }\n    stack.set(source, target);\n    if (Array.isArray(source)) {\n        source = source.slice();\n        for (let i = 0; i < source.length; i++) {\n            source[i] = source[i] ?? undefined;\n        }\n    }\n    const sourceKeys = [...Object.keys(source), ...getSymbols(source)];\n    for (let i = 0; i < sourceKeys.length; i++) {\n        const key = sourceKeys[i];\n        let sourceValue = source[key];\n        let targetValue = target[key];\n        if (isArguments(sourceValue)) {\n            sourceValue = { ...sourceValue };\n        }\n        if (isArguments(targetValue)) {\n            targetValue = { ...targetValue };\n        }\n        if (typeof Buffer !== 'undefined' && Buffer.isBuffer(sourceValue)) {\n            sourceValue = cloneDeep(sourceValue);\n        }\n        if (Array.isArray(sourceValue)) {\n            if (typeof targetValue === 'object' && targetValue != null) {\n                const cloned = [];\n                const targetKeys = Reflect.ownKeys(targetValue);\n                for (let i = 0; i < targetKeys.length; i++) {\n                    const targetKey = targetKeys[i];\n                    cloned[targetKey] = targetValue[targetKey];\n                }\n                targetValue = cloned;\n            }\n            else {\n                targetValue = [];\n            }\n        }\n        const merged = merge(targetValue, sourceValue, key, target, source, stack);\n        if (merged != null) {\n            target[key] = merged;\n        }\n        else if (Array.isArray(sourceValue)) {\n            target[key] = mergeWithDeep(targetValue, sourceValue, merge, stack);\n        }\n        else if (isObjectLike(targetValue) && isObjectLike(sourceValue)) {\n            target[key] = mergeWithDeep(targetValue, sourceValue, merge, stack);\n        }\n        else if (targetValue == null && isPlainObject(sourceValue)) {\n            target[key] = mergeWithDeep({}, sourceValue, merge, stack);\n        }\n        else if (targetValue == null && isTypedArray(sourceValue)) {\n            target[key] = cloneDeep(sourceValue);\n        }\n        else if (targetValue === undefined || sourceValue !== undefined) {\n            target[key] = sourceValue;\n        }\n    }\n    return target;\n}\n\nexport { mergeWith };\n","import { mergeWith } from './mergeWith.mjs';\nimport { noop } from '../../function/noop.mjs';\n\nfunction merge(object, ...sources) {\n    return mergeWith(object, ...sources, noop);\n}\n\nexport { merge };\n","import { SessionTypes } from \"@walletconnect/types\";\nimport {\n  isCaipNamespace,\n  isValidObject,\n  mergeArrays,\n  parseChainId,\n  parseNamespaceKey,\n} from \"@walletconnect/utils\";\nimport { RPC_URL } from \"../constants\";\nimport { Namespace, NamespaceConfig } from \"../types\";\nimport { merge } from \"es-toolkit/compat\";\n\nexport function getRpcUrl(chainId: string, rpc: Namespace, projectId?: string): string | undefined {\n  const chain = parseChainId(chainId);\n  return (\n    rpc.rpcMap?.[chain.reference] ||\n    `${RPC_URL}?chainId=${chain.namespace}:${chain.reference}&projectId=${projectId}`\n  );\n}\n\nexport function getChainId(chain: string): string {\n  return chain.includes(\":\") ? chain.split(\":\")[1] : chain;\n}\n\nexport function validateChainApproval(chain: string, chains: string[]): void {\n  if (!chains.includes(chain)) {\n    throw new Error(\n      `Chain '${chain}' not approved. Please use one of the following: ${chains.toString()}`,\n    );\n  }\n}\n\nexport function getChainsFromApprovedSession(accounts: string[]): string[] {\n  return accounts.map((address) => `${address.split(\":\")[0]}:${address.split(\":\")[1]}`);\n}\n\nexport function getAccountsFromSession(namespace: string, session: SessionTypes.Struct): string[] {\n  // match namespaces e.g. eip155 with eip155:1\n  const matchedNamespaceKeys = Object.keys(session.namespaces).filter((key) =>\n    key.includes(namespace),\n  );\n  if (!matchedNamespaceKeys.length) return [];\n  const accounts: string[] = [];\n  matchedNamespaceKeys.forEach((key) => {\n    const accountsForNamespace = session.namespaces[key].accounts;\n    accounts.push(...accountsForNamespace);\n  });\n  return accounts;\n}\n\nexport function mergeRequiredOptionalNamespaces(\n  required: NamespaceConfig = {},\n  optional: NamespaceConfig = {},\n) {\n  const requiredNamespaces = normalizeNamespaces(required);\n  const optionalNamespaces = normalizeNamespaces(optional);\n  return merge(requiredNamespaces, optionalNamespaces);\n}\n\n/**\n * Converts\n * {\n *  \"eip155:1\": {...},\n *  \"eip155:2\": {...},\n * }\n * into\n * {\n *  \"eip155\": {\n *      chains: [\"eip155:1\", \"eip155:2\"],\n *      ...\n *    }\n * }\n *\n */\nexport function normalizeNamespaces(namespaces: NamespaceConfig): NamespaceConfig {\n  const normalizedNamespaces: NamespaceConfig = {};\n  if (!isValidObject(namespaces)) return normalizedNamespaces;\n\n  for (const [key, values] of Object.entries(namespaces)) {\n    const chains = isCaipNamespace(key) ? [key] : values.chains;\n    const methods = values.methods || [];\n    const events = values.events || [];\n    const rpcMap = values.rpcMap || {};\n    const normalizedKey = parseNamespaceKey(key);\n    normalizedNamespaces[normalizedKey] = {\n      ...normalizedNamespaces[normalizedKey],\n      ...values,\n      chains: mergeArrays(chains, normalizedNamespaces[normalizedKey]?.chains),\n      methods: mergeArrays(methods, normalizedNamespaces[normalizedKey]?.methods),\n      events: mergeArrays(events, normalizedNamespaces[normalizedKey]?.events),\n    };\n    // avoid adding empty `rpcMap: {}` if there are no values for it\n    if (isValidObject(rpcMap) || isValidObject(normalizedNamespaces[normalizedKey]?.rpcMap || {})) {\n      normalizedNamespaces[normalizedKey].rpcMap = {\n        ...rpcMap,\n        ...normalizedNamespaces[normalizedKey]?.rpcMap,\n      };\n    }\n  }\n  return normalizedNamespaces;\n}\n\nexport function parseCaip10Account(caip10Account: string): string {\n  return caip10Account.includes(\":\") ? caip10Account.split(\":\")[2] : caip10Account;\n}\n\n/**\n * Populates the chains array for each namespace with the chains extracted from the accounts if are otherwise missing\n */\nexport function populateNamespacesChains(\n  namespaces: SessionTypes.Namespaces,\n): Record<string, SessionTypes.Namespace> {\n  const parsedNamespaces: Record<string, SessionTypes.Namespace> = {};\n  for (const [key, values] of Object.entries(namespaces)) {\n    const methods = values.methods || [];\n    const events = values.events || [];\n    const accounts = values.accounts || [];\n    // If the key includes a CAIP separator `:` we know it's a namespace + chainId (e.g. `eip155:1`)\n    const chains = isCaipNamespace(key)\n      ? [key]\n      : values.chains\n        ? values.chains\n        : getChainsFromApprovedSession(values.accounts);\n    parsedNamespaces[key] = {\n      chains,\n      methods,\n      events,\n      accounts,\n    };\n  }\n  return parsedNamespaces;\n}\n\nexport function convertChainIdToNumber(chainId: string | number): number | string {\n  if (typeof chainId === \"number\") return chainId;\n  if (chainId.includes(\"0x\")) {\n    return parseInt(chainId, 16);\n  }\n\n  chainId = chainId.includes(\":\") ? chainId.split(\":\")[1] : chainId;\n  return isNaN(Number(chainId)) ? chainId : Number(chainId);\n}\n","const globals = {};\nexport const getGlobal = (key: string) => {\n  return globals[key];\n};\n\nexport const setGlobal = (key: string, value: unknown) => {\n  globals[key] = value;\n};\n","import HttpConnection from \"@walletconnect/jsonrpc-http-connection\";\nimport { JsonRpcProvider } from \"@walletconnect/jsonrpc-provider\";\nimport Client from \"@walletconnect/sign-client\";\nimport { EngineTypes, SessionTypes } from \"@walletconnect/types\";\nimport EventEmitter from \"events\";\nimport { PROVIDER_EVENTS } from \"../constants\";\nimport {\n  IProvider,\n  RequestParams,\n  RpcProvidersMap,\n  SessionNamespace,\n  SubProviderOpts,\n} from \"../types\";\n\nimport { getChainId, getGlobal, getRpcUrl } from \"../utils\";\n\nclass PolkadotProvider implements IProvider {\n  public name = \"polkadot\";\n  public client: Client;\n  public httpProviders: RpcProvidersMap;\n  public events: EventEmitter;\n  public namespace: SessionNamespace;\n  public chainId: string;\n\n  constructor(opts: SubProviderOpts) {\n    this.namespace = opts.namespace;\n    this.events = getGlobal(\"events\");\n    this.client = getGlobal(\"client\");\n    this.chainId = this.getDefaultChain();\n    this.httpProviders = this.createHttpProviders();\n  }\n\n  public updateNamespace(namespace: SessionTypes.Namespace) {\n    this.namespace = Object.assign(this.namespace, namespace);\n  }\n\n  public requestAccounts(): string[] {\n    return this.getAccounts();\n  }\n\n  public getDefaultChain(): string {\n    if (this.chainId) return this.chainId;\n    if (this.namespace.defaultChain) return this.namespace.defaultChain;\n\n    const chainId = this.namespace.chains[0];\n\n    if (!chainId) throw new Error(`ChainId not found`);\n\n    return chainId.split(\":\")[1];\n  }\n\n  public request<T = unknown>(args: RequestParams): Promise<T> {\n    if (this.namespace.methods.includes(args.request.method)) {\n      return this.client.request(args as EngineTypes.RequestParams);\n    }\n    return this.getHttpProvider().request(args.request);\n  }\n\n  public setDefaultChain(chainId: string, rpcUrl?: string | undefined) {\n    // http provider exists so just set the chainId\n    if (!this.httpProviders[chainId]) {\n      this.setHttpProvider(chainId, rpcUrl);\n    }\n    this.chainId = chainId;\n    this.events.emit(PROVIDER_EVENTS.DEFAULT_CHAIN_CHANGED, `${this.name}:${chainId}`);\n  }\n\n  // ---------------- PRIVATE ---------------- //\n\n  private getAccounts(): string[] {\n    const accounts = this.namespace.accounts;\n    if (!accounts) {\n      return [];\n    }\n\n    return (\n      accounts\n        // get the accounts from the active chain\n        .filter((account) => account.split(\":\")[1] === this.chainId.toString())\n        // remove namespace & chainId from the string\n        .map((account) => account.split(\":\")[2]) || []\n    );\n  }\n\n  private createHttpProviders(): RpcProvidersMap {\n    const http = {};\n    this.namespace.chains.forEach((chain) => {\n      const parsedChainId = getChainId(chain);\n      http[parsedChainId] = this.createHttpProvider(parsedChainId, this.namespace.rpcMap?.[chain]);\n    });\n    return http;\n  }\n\n  private getHttpProvider(): JsonRpcProvider {\n    const chain = `${this.name}:${this.chainId}`;\n    const http = this.httpProviders[chain];\n    if (typeof http === \"undefined\") {\n      throw new Error(`JSON-RPC provider for ${chain} not found`);\n    }\n    return http;\n  }\n\n  private setHttpProvider(chainId: string, rpcUrl?: string): void {\n    const http = this.createHttpProvider(chainId, rpcUrl);\n    if (http) {\n      this.httpProviders[chainId] = http;\n    }\n  }\n\n  private createHttpProvider(\n    chainId: string,\n    rpcUrl?: string | undefined,\n  ): JsonRpcProvider | undefined {\n    const rpc = rpcUrl || getRpcUrl(chainId, this.namespace, this.client.core.projectId);\n    if (!rpc) {\n      throw new Error(`No RPC url provided for chainId: ${chainId}`);\n    }\n    const http = new JsonRpcProvider(new HttpConnection(rpc, getGlobal(\"disableProviderPing\")));\n    return http;\n  }\n}\n\nexport default PolkadotProvider;\n","import Client from \"@walletconnect/sign-client\";\nimport { JsonRpcProvider } from \"@walletconnect/jsonrpc-provider\";\nimport { HttpConnection } from \"@walletconnect/jsonrpc-http-connection\";\nimport { EngineTypes, SessionTypes } from \"@walletconnect/types\";\n\nimport {\n  IProvider,\n  RpcProvidersMap,\n  SubProviderOpts,\n  RequestParams,\n  SessionNamespace,\n} from \"../types\";\n\nimport { getChainId, getGlobal, getRpcUrl } from \"../utils\";\nimport EventEmitter from \"events\";\nimport { BUNDLER_URL, PROVIDER_EVENTS } from \"../constants\";\nimport { formatJsonRpcRequest } from \"@walletconnect/jsonrpc-utils\";\n\nclass Eip155Provider implements IProvider {\n  public name = \"eip155\";\n  public client: Client;\n  // the active chainId on the dapp\n  public chainId: number;\n  public namespace: SessionNamespace;\n  public httpProviders: RpcProvidersMap;\n  public events: EventEmitter;\n\n  constructor(opts: SubProviderOpts) {\n    this.namespace = opts.namespace;\n    this.events = getGlobal(\"events\");\n    this.client = getGlobal(\"client\");\n    this.httpProviders = this.createHttpProviders();\n    this.chainId = parseInt(this.getDefaultChain());\n  }\n\n  public async request<T = unknown>(args: RequestParams): Promise<T> {\n    switch (args.request.method) {\n      case \"eth_requestAccounts\":\n        return this.getAccounts() as unknown as T;\n      case \"eth_accounts\":\n        return this.getAccounts() as unknown as T;\n      case \"wallet_switchEthereumChain\": {\n        return (await this.handleSwitchChain(args)) as unknown as T;\n      }\n      case \"eth_chainId\":\n        return parseInt(this.getDefaultChain()) as unknown as T;\n      case \"wallet_getCapabilities\":\n        return (await this.getCapabilities(args)) as unknown as T;\n      case \"wallet_getCallsStatus\":\n        return (await this.getCallStatus(args)) as unknown as T;\n      default:\n        break;\n    }\n    if (this.namespace.methods.includes(args.request.method)) {\n      return await this.client.request(args as EngineTypes.RequestParams);\n    }\n    return this.getHttpProvider().request(args.request);\n  }\n\n  public updateNamespace(namespace: SessionTypes.Namespace) {\n    this.namespace = Object.assign(this.namespace, namespace);\n  }\n\n  public setDefaultChain(chainId: string, rpcUrl?: string | undefined) {\n    // http provider exists so just set the chainId\n    if (!this.httpProviders[chainId]) {\n      this.setHttpProvider(parseInt(chainId), rpcUrl);\n    }\n    this.chainId = parseInt(chainId);\n    this.events.emit(PROVIDER_EVENTS.DEFAULT_CHAIN_CHANGED, `${this.name}:${chainId}`);\n  }\n\n  public requestAccounts(): string[] {\n    return this.getAccounts();\n  }\n\n  public getDefaultChain(): string {\n    if (this.chainId) return this.chainId.toString();\n    if (this.namespace.defaultChain) return this.namespace.defaultChain;\n\n    const chainId = this.namespace.chains[0];\n    if (!chainId) throw new Error(`ChainId not found`);\n\n    return chainId.split(\":\")[1];\n  }\n\n  // ---------- Private ----------------------------------------------- //\n\n  private createHttpProvider(\n    chainId: number,\n    rpcUrl?: string | undefined,\n  ): JsonRpcProvider | undefined {\n    const rpc =\n      rpcUrl || getRpcUrl(`${this.name}:${chainId}`, this.namespace, this.client.core.projectId);\n    if (!rpc) {\n      throw new Error(`No RPC url provided for chainId: ${chainId}`);\n    }\n    const http = new JsonRpcProvider(new HttpConnection(rpc, getGlobal(\"disableProviderPing\")));\n    return http;\n  }\n\n  private setHttpProvider(chainId: number, rpcUrl?: string): void {\n    const http = this.createHttpProvider(chainId, rpcUrl);\n    if (http) {\n      this.httpProviders[chainId] = http;\n    }\n  }\n\n  private createHttpProviders(): RpcProvidersMap {\n    const http = {};\n    this.namespace.chains.forEach((chain) => {\n      const parsedChain = parseInt(getChainId(chain));\n      http[parsedChain] = this.createHttpProvider(parsedChain, this.namespace.rpcMap?.[chain]);\n    });\n    return http;\n  }\n\n  private getAccounts(): string[] {\n    const accounts = this.namespace.accounts;\n    if (!accounts) {\n      return [];\n    }\n    return [\n      ...new Set(\n        accounts\n          // get the accounts from the active chain\n          .filter((account) => account.split(\":\")[1] === this.chainId.toString())\n          // remove namespace & chainId from the string\n          .map((account) => account.split(\":\")[2]),\n      ),\n    ];\n  }\n\n  private getHttpProvider(): JsonRpcProvider {\n    const chain = this.chainId;\n    const http = this.httpProviders[chain];\n    if (typeof http === \"undefined\") {\n      throw new Error(`JSON-RPC provider for ${chain} not found`);\n    }\n    return http;\n  }\n\n  private async handleSwitchChain(args: RequestParams): Promise<any> {\n    let hexChainId = args.request.params ? args.request.params[0]?.chainId : \"0x0\";\n    hexChainId = hexChainId.startsWith(\"0x\") ? hexChainId : `0x${hexChainId}`;\n    const parsedChainId = parseInt(hexChainId, 16);\n    // if chainId is already approved, switch locally\n    if (this.isChainApproved(parsedChainId)) {\n      this.setDefaultChain(`${parsedChainId}`);\n    } else if (this.namespace.methods.includes(\"wallet_switchEthereumChain\")) {\n      // try to switch chain within the wallet\n      await this.client.request({\n        topic: args.topic,\n        request: {\n          method: args.request.method,\n          params: [\n            {\n              chainId: hexChainId,\n            },\n          ],\n        },\n        chainId: this.namespace.chains?.[0], // Sending a previously unapproved chainId will cause namespace validation failure so we must set request chainId to the first chainId in the namespace to avoid it\n      } as EngineTypes.RequestParams);\n      this.setDefaultChain(`${parsedChainId}`);\n    } else {\n      throw new Error(\n        `Failed to switch to chain 'eip155:${parsedChainId}'. The chain is not approved or the wallet does not support 'wallet_switchEthereumChain' method.`,\n      );\n    }\n    return null;\n  }\n\n  private isChainApproved(chainId: number): boolean {\n    return this.namespace.chains.includes(`${this.name}:${chainId}`);\n  }\n\n  private async getCapabilities(args: RequestParams) {\n    // if capabilities are stored in the session, return them, else send the request to the wallet\n    const address = args.request?.params?.[0];\n    const chainIds: string[] = args.request?.params?.[1] || [];\n\n    // cache key is address + chainIds to allow requests to be made to different chains\n    const capabilitiesKey = `${address}${chainIds.join(\",\")}`;\n    if (!address) throw new Error(\"Missing address parameter in `wallet_getCapabilities` request\");\n    const session = this.client.session.get(args.topic);\n    const sessionCapabilities = session?.sessionProperties?.capabilities || {};\n\n    if (sessionCapabilities?.[capabilitiesKey]) {\n      return sessionCapabilities?.[capabilitiesKey];\n    }\n\n    // intentionally omit catching errors/rejection during `request` to allow the error to bubble up\n    const capabilities = await this.client.request(args as EngineTypes.RequestParams);\n    try {\n      // update the session with the capabilities so they can be retrieved later\n      await this.client.session.update(args.topic, {\n        sessionProperties: {\n          ...(session.sessionProperties || {}),\n          capabilities: {\n            ...(sessionCapabilities || {}),\n            [capabilitiesKey]: capabilities,\n          } as any, // by spec sessionProperties should be <string, string> but here are used as objects?\n        },\n      });\n    } catch (error) {\n      console.warn(\"Failed to update session with capabilities\", error);\n    }\n    return capabilities;\n  }\n\n  private async getCallStatus(args: RequestParams) {\n    const session = this.client.session.get(args.topic);\n    const bundlerName = session.sessionProperties?.bundler_name;\n    if (bundlerName) {\n      const bundlerUrl = this.getBundlerUrl(args.chainId, bundlerName);\n      try {\n        return await this.getUserOperationReceipt(bundlerUrl, args);\n      } catch (error) {\n        console.warn(\"Failed to fetch call status from bundler\", error, bundlerUrl);\n      }\n    }\n    const customUrl = session.sessionProperties?.bundler_url;\n    if (customUrl) {\n      try {\n        return await this.getUserOperationReceipt(customUrl, args);\n      } catch (error) {\n        console.warn(\"Failed to fetch call status from custom bundler\", error, customUrl);\n      }\n    }\n\n    if (this.namespace.methods.includes(args.request.method)) {\n      return await this.client.request(args as EngineTypes.RequestParams);\n    }\n\n    throw new Error(\"Fetching call status not approved by the wallet.\");\n  }\n\n  private async getUserOperationReceipt(bundlerUrl: string, args: RequestParams) {\n    const url = new URL(bundlerUrl);\n    const response = await fetch(url, {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n      },\n      body: JSON.stringify(\n        formatJsonRpcRequest(\"eth_getUserOperationReceipt\", [args.request.params?.[0]]),\n      ),\n    });\n    if (!response.ok) {\n      throw new Error(`Failed to fetch user operation receipt - ${response.status}`);\n    }\n    return await response.json();\n  }\n\n  private getBundlerUrl(cap2ChainId: string, bundlerName: string) {\n    return `${BUNDLER_URL}?projectId=${this.client.core.projectId}&chainId=${cap2ChainId}&bundler=${bundlerName}`;\n  }\n}\n\nexport default Eip155Provider;\n","import HttpConnection from \"@walletconnect/jsonrpc-http-connection\";\nimport { JsonRpcProvider } from \"@walletconnect/jsonrpc-provider\";\nimport Client from \"@walletconnect/sign-client\";\nimport { EngineTypes, SessionTypes } from \"@walletconnect/types\";\nimport EventEmitter from \"events\";\nimport { PROVIDER_EVENTS } from \"../constants\";\nimport {\n  IProvider,\n  RequestParams,\n  RpcProvidersMap,\n  SessionNamespace,\n  SubProviderOpts,\n} from \"../types\";\nimport { getChainId, getGlobal, getRpcUrl } from \"../utils\";\n\nclass SolanaProvider implements IProvider {\n  public name = \"solana\";\n  public client: Client;\n  public httpProviders: RpcProvidersMap;\n  public events: EventEmitter;\n  public namespace: SessionNamespace;\n  public chainId: string;\n\n  constructor(opts: SubProviderOpts) {\n    this.namespace = opts.namespace;\n    this.events = getGlobal(\"events\");\n    this.client = getGlobal(\"client\");\n    this.chainId = this.getDefaultChain();\n    this.httpProviders = this.createHttpProviders();\n  }\n\n  public updateNamespace(namespace: SessionTypes.Namespace) {\n    this.namespace = Object.assign(this.namespace, namespace);\n  }\n\n  public requestAccounts(): string[] {\n    return this.getAccounts();\n  }\n\n  public request<T = unknown>(args: RequestParams): Promise<T> {\n    if (this.namespace.methods.includes(args.request.method)) {\n      return this.client.request(args as EngineTypes.RequestParams);\n    }\n    return this.getHttpProvider().request(args.request);\n  }\n\n  public setDefaultChain(chainId: string, rpcUrl?: string | undefined) {\n    // http provider exists so just set the chainId\n    if (!this.httpProviders[chainId]) {\n      this.setHttpProvider(chainId, rpcUrl);\n    }\n    this.chainId = chainId;\n    this.events.emit(PROVIDER_EVENTS.DEFAULT_CHAIN_CHANGED, `${this.name}:${chainId}`);\n  }\n\n  public getDefaultChain(): string {\n    if (this.chainId) return this.chainId;\n    if (this.namespace.defaultChain) return this.namespace.defaultChain;\n\n    const chainId = this.namespace.chains[0];\n    if (!chainId) throw new Error(`ChainId not found`);\n\n    return chainId.split(\":\")[1];\n  }\n\n  // --------- PRIVATE --------- //\n\n  private getAccounts(): string[] {\n    const accounts = this.namespace.accounts;\n    if (!accounts) {\n      return [];\n    }\n\n    return [\n      ...new Set(\n        accounts\n          // get the accounts from the active chain\n          .filter((account) => account.split(\":\")[1] === this.chainId.toString())\n          // remove namespace & chainId from the string\n          .map((account) => account.split(\":\")[2]),\n      ),\n    ];\n  }\n\n  private createHttpProviders(): RpcProvidersMap {\n    const http = {};\n    this.namespace.chains.forEach((chain) => {\n      const parsedChainId = getChainId(chain);\n      http[parsedChainId] = this.createHttpProvider(parsedChainId, this.namespace.rpcMap?.[chain]);\n    });\n    return http;\n  }\n\n  private getHttpProvider(): JsonRpcProvider {\n    const chain = `${this.name}:${this.chainId}`;\n    const http = this.httpProviders[chain];\n    if (typeof http === \"undefined\") {\n      throw new Error(`JSON-RPC provider for ${chain} not found`);\n    }\n    return http;\n  }\n\n  private setHttpProvider(chainId: string, rpcUrl?: string): void {\n    const http = this.createHttpProvider(chainId, rpcUrl);\n    if (http) {\n      this.httpProviders[chainId] = http;\n    }\n  }\n\n  private createHttpProvider(\n    chainId: string,\n    rpcUrl?: string | undefined,\n  ): JsonRpcProvider | undefined {\n    const rpc = rpcUrl || getRpcUrl(chainId, this.namespace, this.client.core.projectId);\n    if (!rpc) {\n      throw new Error(`No RPC url provided for chainId: ${chainId}`);\n    }\n    const http = new JsonRpcProvider(new HttpConnection(rpc, getGlobal(\"disableProviderPing\")));\n    return http;\n  }\n}\n\nexport default SolanaProvider;\n","import HttpConnection from \"@walletconnect/jsonrpc-http-connection\";\nimport { JsonRpcProvider } from \"@walletconnect/jsonrpc-provider\";\nimport Client from \"@walletconnect/sign-client\";\nimport { EngineTypes, SessionTypes } from \"@walletconnect/types\";\nimport EventEmitter from \"events\";\nimport { PROVIDER_EVENTS } from \"../constants\";\nimport {\n  IProvider,\n  RequestParams,\n  RpcProvidersMap,\n  SessionNamespace,\n  SubProviderOpts,\n} from \"../types\";\nimport { getChainId, getGlobal, getRpcUrl } from \"../utils\";\n\nclass CosmosProvider implements IProvider {\n  public name = \"cosmos\";\n  public client: Client;\n  public httpProviders: RpcProvidersMap;\n  public events: EventEmitter;\n  public namespace: SessionNamespace;\n  public chainId: string;\n\n  constructor(opts: SubProviderOpts) {\n    this.namespace = opts.namespace;\n    this.events = getGlobal(\"events\");\n    this.client = getGlobal(\"client\");\n    this.chainId = this.getDefaultChain();\n    this.httpProviders = this.createHttpProviders();\n  }\n\n  public updateNamespace(namespace: SessionTypes.Namespace) {\n    this.namespace = Object.assign(this.namespace, namespace);\n  }\n\n  public requestAccounts(): string[] {\n    return this.getAccounts();\n  }\n\n  public getDefaultChain(): string {\n    if (this.chainId) return this.chainId;\n    if (this.namespace.defaultChain) return this.namespace.defaultChain;\n\n    const chainId = this.namespace.chains[0];\n\n    if (!chainId) throw new Error(`ChainId not found`);\n\n    return chainId.split(\":\")[1];\n  }\n\n  public request<T = unknown>(args: RequestParams): Promise<T> {\n    if (this.namespace.methods.includes(args.request.method)) {\n      return this.client.request(args as EngineTypes.RequestParams);\n    }\n    return this.getHttpProvider().request(args.request);\n  }\n\n  public setDefaultChain(chainId: string, rpcUrl?: string | undefined) {\n    // http provider exists so just set the chainId\n    if (!this.httpProviders[chainId]) {\n      this.setHttpProvider(chainId, rpcUrl);\n    }\n    this.chainId = chainId;\n    this.events.emit(PROVIDER_EVENTS.DEFAULT_CHAIN_CHANGED, `${this.name}:${this.chainId}`);\n  }\n\n  // ---------------- PRIVATE ---------------- //\n\n  private getAccounts(): string[] {\n    const accounts = this.namespace.accounts;\n    if (!accounts) {\n      return [];\n    }\n\n    return [\n      ...new Set(\n        accounts\n          // get the accounts from the active chain\n          .filter((account) => account.split(\":\")[1] === this.chainId.toString())\n          // remove namespace & chainId from the string\n          .map((account) => account.split(\":\")[2]),\n      ),\n    ];\n  }\n\n  private createHttpProviders(): RpcProvidersMap {\n    const http = {};\n    this.namespace.chains.forEach((chain) => {\n      const parsedChainId = getChainId(chain);\n      http[parsedChainId] = this.createHttpProvider(parsedChainId, this.namespace.rpcMap?.[chain]);\n    });\n    return http;\n  }\n\n  private getHttpProvider(): JsonRpcProvider {\n    const chain = `${this.name}:${this.chainId}`;\n    const http = this.httpProviders[chain];\n    if (typeof http === \"undefined\") {\n      throw new Error(`JSON-RPC provider for ${chain} not found`);\n    }\n    return http;\n  }\n\n  private setHttpProvider(chainId: string, rpcUrl?: string): void {\n    const http = this.createHttpProvider(chainId, rpcUrl);\n    if (http) {\n      this.httpProviders[chainId] = http;\n    }\n  }\n\n  private createHttpProvider(\n    chainId: string,\n    rpcUrl?: string | undefined,\n  ): JsonRpcProvider | undefined {\n    const rpc = rpcUrl || getRpcUrl(chainId, this.namespace, this.client.core.projectId);\n    if (!rpc) {\n      throw new Error(`No RPC url provided for chainId: ${chainId}`);\n    }\n    const http = new JsonRpcProvider(new HttpConnection(rpc, getGlobal(\"disableProviderPing\")));\n    return http;\n  }\n}\n\nexport default CosmosProvider;\n","import HttpConnection from \"@walletconnect/jsonrpc-http-connection\";\nimport { JsonRpcProvider } from \"@walletconnect/jsonrpc-provider\";\nimport Client from \"@walletconnect/sign-client\";\nimport { EngineTypes, SessionTypes } from \"@walletconnect/types\";\nimport EventEmitter from \"events\";\nimport { PROVIDER_EVENTS } from \"../constants\";\nimport {\n  IProvider,\n  RequestParams,\n  RpcProvidersMap,\n  SessionNamespace,\n  SubProviderOpts,\n} from \"../types\";\nimport { getGlobal, getRpcUrl } from \"../utils\";\n\nclass AlgorandProvider implements IProvider {\n  public name = \"algorand\";\n  public client: Client;\n  public httpProviders: RpcProvidersMap;\n  public events: EventEmitter;\n  public namespace: SessionNamespace;\n  public chainId: string;\n\n  constructor(opts: SubProviderOpts) {\n    this.namespace = opts.namespace;\n    this.events = getGlobal(\"events\");\n    this.client = getGlobal(\"client\");\n    this.chainId = this.getDefaultChain();\n    this.httpProviders = this.createHttpProviders();\n  }\n\n  public updateNamespace(namespace: SessionTypes.Namespace) {\n    this.namespace = Object.assign(this.namespace, namespace);\n  }\n\n  public requestAccounts(): string[] {\n    return this.getAccounts();\n  }\n\n  public request<T = unknown>(args: RequestParams): Promise<T> {\n    if (this.namespace.methods.includes(args.request.method)) {\n      return this.client.request(args as EngineTypes.RequestParams);\n    }\n    return this.getHttpProvider().request(args.request);\n  }\n\n  public setDefaultChain(chainId: string, rpcUrl?: string | undefined) {\n    // http provider exists so just set the chainId\n    if (!this.httpProviders[chainId]) {\n      const rpc =\n        rpcUrl || getRpcUrl(`${this.name}:${chainId}`, this.namespace, this.client.core.projectId);\n      if (!rpc) {\n        throw new Error(`No RPC url provided for chainId: ${chainId}`);\n      }\n      this.setHttpProvider(chainId, rpc);\n    }\n    this.chainId = chainId;\n    this.events.emit(PROVIDER_EVENTS.DEFAULT_CHAIN_CHANGED, `${this.name}:${this.chainId}`);\n  }\n\n  public getDefaultChain(): string {\n    if (this.chainId) return this.chainId;\n    if (this.namespace.defaultChain) return this.namespace.defaultChain;\n\n    const chainId = this.namespace.chains[0];\n    if (!chainId) throw new Error(`ChainId not found`);\n\n    return chainId.split(\":\")[1];\n  }\n\n  // --------- PRIVATE --------- //\n\n  private getAccounts(): string[] {\n    const accounts = this.namespace.accounts;\n    if (!accounts) {\n      return [];\n    }\n\n    return [\n      ...new Set(\n        accounts\n          // get the accounts from the active chain\n          .filter((account) => account.split(\":\")[1] === this.chainId.toString())\n          // remove namespace & chainId from the string\n          .map((account) => account.split(\":\")[2]),\n      ),\n    ];\n  }\n\n  private createHttpProviders(): RpcProvidersMap {\n    const http = {};\n    this.namespace.chains.forEach((chain) => {\n      http[chain] = this.createHttpProvider(chain, this.namespace.rpcMap?.[chain]);\n    });\n    return http;\n  }\n\n  private getHttpProvider(): JsonRpcProvider {\n    const chain = `${this.name}:${this.chainId}`;\n    const http = this.httpProviders[chain];\n    if (typeof http === \"undefined\") {\n      throw new Error(`JSON-RPC provider for ${chain} not found`);\n    }\n    return http;\n  }\n\n  private setHttpProvider(chainId: string, rpcUrl?: string): void {\n    const http = this.createHttpProvider(chainId, rpcUrl);\n    if (http) {\n      this.httpProviders[chainId] = http;\n    }\n  }\n\n  private createHttpProvider(\n    chainId: string,\n    rpcUrl?: string | undefined,\n  ): JsonRpcProvider | undefined {\n    const rpc = rpcUrl || getRpcUrl(chainId, this.namespace, this.client.core.projectId);\n    if (typeof rpc === \"undefined\") return undefined;\n    const http = new JsonRpcProvider(new HttpConnection(rpc, getGlobal(\"disableProviderPing\")));\n    return http;\n  }\n}\n\nexport default AlgorandProvider;\n","import HttpConnection from \"@walletconnect/jsonrpc-http-connection\";\nimport { JsonRpcProvider } from \"@walletconnect/jsonrpc-provider\";\nimport Client from \"@walletconnect/sign-client\";\nimport { EngineTypes, SessionTypes } from \"@walletconnect/types\";\nimport EventEmitter from \"events\";\nimport { PROVIDER_EVENTS } from \"../constants\";\nimport {\n  IProvider,\n  RequestParams,\n  RpcProvidersMap,\n  SessionNamespace,\n  SubProviderOpts,\n} from \"../types\";\nimport { getChainId, getGlobal } from \"../utils\";\n\nclass CardanoProvider implements IProvider {\n  public name = \"cip34\";\n  public client: Client;\n  public httpProviders: RpcProvidersMap;\n  public events: EventEmitter;\n  public namespace: SessionNamespace;\n  public chainId: string;\n\n  constructor(opts: SubProviderOpts) {\n    this.namespace = opts.namespace;\n    this.events = getGlobal(\"events\");\n    this.client = getGlobal(\"client\");\n    this.chainId = this.getDefaultChain();\n    this.httpProviders = this.createHttpProviders();\n  }\n\n  public updateNamespace(namespace: SessionTypes.Namespace) {\n    this.namespace = Object.assign(this.namespace, namespace);\n  }\n\n  public requestAccounts(): string[] {\n    return this.getAccounts();\n  }\n\n  public getDefaultChain(): string {\n    if (this.chainId) return this.chainId;\n    if (this.namespace.defaultChain) return this.namespace.defaultChain;\n\n    const chainId = this.namespace.chains[0];\n    if (!chainId) throw new Error(`ChainId not found`);\n\n    return chainId.split(\":\")[1];\n  }\n\n  public request<T = unknown>(args: RequestParams): Promise<T> {\n    if (this.namespace.methods.includes(args.request.method)) {\n      return this.client.request(args as EngineTypes.RequestParams);\n    }\n    return this.getHttpProvider().request(args.request);\n  }\n\n  public setDefaultChain(chainId: string, rpcUrl?: string | undefined) {\n    // http provider exists so just set the chainId\n    if (!this.httpProviders[chainId]) {\n      this.setHttpProvider(chainId, rpcUrl);\n    }\n    this.chainId = chainId;\n    this.events.emit(PROVIDER_EVENTS.DEFAULT_CHAIN_CHANGED, `${this.name}:${this.chainId}`);\n  }\n\n  // ------------- PRIVATE -------------- /\n\n  private getAccounts(): string[] {\n    const accounts = this.namespace.accounts;\n    if (!accounts) {\n      return [];\n    }\n\n    return [\n      ...new Set(\n        accounts\n          // get the accounts from the active chain\n          .filter((account) => account.split(\":\")[1] === this.chainId.toString())\n          // remove namespace & chainId from the string\n          .map((account) => account.split(\":\")[2]),\n      ),\n    ];\n  }\n\n  private createHttpProviders(): RpcProvidersMap {\n    const http = {};\n    this.namespace.chains.forEach((chain) => {\n      const rpcURL = this.getCardanoRPCUrl(chain);\n      const parsedChain = getChainId(chain);\n      http[parsedChain] = this.createHttpProvider(parsedChain, rpcURL);\n    });\n    return http;\n  }\n\n  private getHttpProvider(): JsonRpcProvider {\n    const chain = `${this.name}:${this.chainId}`;\n    const http = this.httpProviders[chain];\n    if (typeof http === \"undefined\") {\n      throw new Error(`JSON-RPC provider for ${chain} not found`);\n    }\n    return http;\n  }\n\n  private getCardanoRPCUrl(chainId: string): string | undefined {\n    const rpcMap = this.namespace.rpcMap;\n    if (!rpcMap) return undefined;\n    return rpcMap[chainId];\n  }\n\n  private setHttpProvider(chainId: string, rpcUrl?: string): void {\n    const http = this.createHttpProvider(chainId, rpcUrl);\n    if (http) {\n      this.httpProviders[chainId] = http;\n    }\n  }\n\n  private createHttpProvider(\n    chainId: string,\n    rpcUrl?: string | undefined,\n  ): JsonRpcProvider | undefined {\n    const rpc = rpcUrl || this.getCardanoRPCUrl(chainId);\n    if (!rpc) {\n      throw new Error(`No RPC url provided for chainId: ${chainId}`);\n    }\n    const http = new JsonRpcProvider(new HttpConnection(rpc, getGlobal(\"disableProviderPing\")));\n    return http;\n  }\n}\n\nexport default CardanoProvider;\n","import HttpConnection from \"@walletconnect/jsonrpc-http-connection\";\nimport { JsonRpcProvider } from \"@walletconnect/jsonrpc-provider\";\nimport Client from \"@walletconnect/sign-client\";\nimport { EngineTypes, SessionTypes } from \"@walletconnect/types\";\nimport EventEmitter from \"events\";\nimport { PROVIDER_EVENTS } from \"../constants\";\nimport {\n  IProvider,\n  RequestParams,\n  RpcProvidersMap,\n  SessionNamespace,\n  SubProviderOpts,\n} from \"../types\";\nimport { getChainId, getGlobal, getRpcUrl } from \"../utils\";\n\n// Old wallet connect provider for Elrond\nclass ElrondProvider implements IProvider {\n  public name = \"elrond\";\n  public client: Client;\n  public httpProviders: RpcProvidersMap;\n  public events: EventEmitter;\n  public namespace: SessionNamespace;\n  public chainId: string;\n\n  constructor(opts: SubProviderOpts) {\n    this.namespace = opts.namespace;\n    this.events = getGlobal(\"events\");\n    this.client = getGlobal(\"client\");\n    this.chainId = this.getDefaultChain();\n    this.httpProviders = this.createHttpProviders();\n  }\n\n  public updateNamespace(namespace: SessionTypes.Namespace) {\n    this.namespace = Object.assign(this.namespace, namespace);\n  }\n\n  public requestAccounts(): string[] {\n    return this.getAccounts();\n  }\n\n  public request<T = unknown>(args: RequestParams): Promise<T> {\n    if (this.namespace.methods.includes(args.request.method)) {\n      return this.client.request(args as EngineTypes.RequestParams);\n    }\n    return this.getHttpProvider().request(args.request);\n  }\n\n  public setDefaultChain(chainId: string, rpcUrl?: string | undefined) {\n    // http provider exists so just set the chainId\n    if (!this.httpProviders[chainId]) {\n      this.setHttpProvider(chainId, rpcUrl);\n    }\n    this.chainId = chainId;\n    this.events.emit(PROVIDER_EVENTS.DEFAULT_CHAIN_CHANGED, `${this.name}:${chainId}`);\n  }\n\n  public getDefaultChain(): string {\n    if (this.chainId) return this.chainId;\n    if (this.namespace.defaultChain) return this.namespace.defaultChain;\n\n    const chainId = this.namespace.chains[0];\n    if (!chainId) throw new Error(`ChainId not found`);\n\n    return chainId.split(\":\")[1];\n  }\n\n  // --------- PRIVATE --------- //\n\n  private getAccounts(): string[] {\n    const accounts = this.namespace.accounts;\n    if (!accounts) {\n      return [];\n    }\n\n    return [\n      ...new Set(\n        accounts\n          // get the accounts from the active chain\n          .filter((account) => account.split(\":\")[1] === this.chainId.toString())\n          // remove namespace & chainId from the string\n          .map((account) => account.split(\":\")[2]),\n      ),\n    ];\n  }\n\n  private createHttpProviders(): RpcProvidersMap {\n    const http = {};\n    this.namespace.chains.forEach((chain) => {\n      const parsedChainId = getChainId(chain);\n      http[parsedChainId] = this.createHttpProvider(parsedChainId, this.namespace.rpcMap?.[chain]);\n    });\n    return http;\n  }\n\n  private getHttpProvider(): JsonRpcProvider {\n    const chain = `${this.name}:${this.chainId}`;\n    const http = this.httpProviders[chain];\n    if (typeof http === \"undefined\") {\n      throw new Error(`JSON-RPC provider for ${chain} not found`);\n    }\n    return http;\n  }\n\n  private setHttpProvider(chainId: string, rpcUrl?: string): void {\n    const http = this.createHttpProvider(chainId, rpcUrl);\n    if (http) {\n      this.httpProviders[chainId] = http;\n    }\n  }\n\n  private createHttpProvider(\n    chainId: string,\n    rpcUrl?: string | undefined,\n  ): JsonRpcProvider | undefined {\n    const rpc = rpcUrl || getRpcUrl(chainId, this.namespace, this.client.core.projectId);\n    if (!rpc) {\n      throw new Error(`No RPC url provided for chainId: ${chainId}`);\n    }\n    const http = new JsonRpcProvider(new HttpConnection(rpc, getGlobal(\"disableProviderPing\")));\n    return http;\n  }\n}\n\nexport default ElrondProvider;\n","import HttpConnection from \"@walletconnect/jsonrpc-http-connection\";\nimport { JsonRpcProvider } from \"@walletconnect/jsonrpc-provider\";\nimport Client from \"@walletconnect/sign-client\";\nimport { EngineTypes, SessionTypes } from \"@walletconnect/types\";\nimport EventEmitter from \"events\";\nimport { PROVIDER_EVENTS } from \"../constants\";\nimport {\n  IProvider,\n  RequestParams,\n  RpcProvidersMap,\n  SessionNamespace,\n  SubProviderOpts,\n} from \"../types\";\nimport { getChainId, getGlobal, getRpcUrl } from \"../utils\";\n\nclass MultiversXProvider implements IProvider {\n  public name = \"multiversx\";\n  public client: Client;\n  public httpProviders: RpcProvidersMap;\n  public events: EventEmitter;\n  public namespace: SessionNamespace;\n  public chainId: string;\n\n  constructor(opts: SubProviderOpts) {\n    this.namespace = opts.namespace;\n    this.events = getGlobal(\"events\");\n    this.client = getGlobal(\"client\");\n    this.chainId = this.getDefaultChain();\n    this.httpProviders = this.createHttpProviders();\n  }\n\n  public updateNamespace(namespace: SessionTypes.Namespace) {\n    this.namespace = Object.assign(this.namespace, namespace);\n  }\n\n  public requestAccounts(): string[] {\n    return this.getAccounts();\n  }\n\n  public request<T = unknown>(args: RequestParams): Promise<T> {\n    if (this.namespace.methods.includes(args.request.method)) {\n      return this.client.request(args as EngineTypes.RequestParams);\n    }\n    return this.getHttpProvider().request(args.request);\n  }\n\n  public setDefaultChain(chainId: string, rpcUrl?: string | undefined) {\n    // http provider exists so just set the chainId\n    if (!this.httpProviders[chainId]) {\n      this.setHttpProvider(chainId, rpcUrl);\n    }\n    this.chainId = chainId;\n    this.events.emit(PROVIDER_EVENTS.DEFAULT_CHAIN_CHANGED, `${this.name}:${chainId}`);\n  }\n\n  public getDefaultChain(): string {\n    if (this.chainId) return this.chainId;\n    if (this.namespace.defaultChain) return this.namespace.defaultChain;\n\n    const chainId = this.namespace.chains[0];\n    if (!chainId) throw new Error(`ChainId not found`);\n\n    return chainId.split(\":\")[1];\n  }\n\n  // --------- PRIVATE --------- //\n\n  private getAccounts(): string[] {\n    const accounts = this.namespace.accounts;\n    if (!accounts) {\n      return [];\n    }\n\n    return [\n      ...new Set(\n        accounts\n          // get the accounts from the active chain\n          .filter((account) => account.split(\":\")[1] === this.chainId.toString())\n          // remove namespace & chainId from the string\n          .map((account) => account.split(\":\")[2]),\n      ),\n    ];\n  }\n\n  private createHttpProviders(): RpcProvidersMap {\n    const http = {};\n    this.namespace.chains.forEach((chain) => {\n      const parsedChainId = getChainId(chain);\n      http[parsedChainId] = this.createHttpProvider(parsedChainId, this.namespace.rpcMap?.[chain]);\n    });\n    return http;\n  }\n\n  private getHttpProvider(): JsonRpcProvider {\n    const chain = `${this.name}:${this.chainId}`;\n    const http = this.httpProviders[chain];\n    if (typeof http === \"undefined\") {\n      throw new Error(`JSON-RPC provider for ${chain} not found`);\n    }\n    return http;\n  }\n\n  private setHttpProvider(chainId: string, rpcUrl?: string): void {\n    const http = this.createHttpProvider(chainId, rpcUrl);\n    if (http) {\n      this.httpProviders[chainId] = http;\n    }\n  }\n\n  private createHttpProvider(\n    chainId: string,\n    rpcUrl?: string | undefined,\n  ): JsonRpcProvider | undefined {\n    const rpc = rpcUrl || getRpcUrl(chainId, this.namespace, this.client.core.projectId);\n    if (!rpc) {\n      throw new Error(`No RPC url provided for chainId: ${chainId}`);\n    }\n    const http = new JsonRpcProvider(new HttpConnection(rpc, getGlobal(\"disableProviderPing\")));\n    return http;\n  }\n}\n\nexport default MultiversXProvider;\n","import HttpConnection from \"@walletconnect/jsonrpc-http-connection\";\nimport { JsonRpcProvider } from \"@walletconnect/jsonrpc-provider\";\nimport Client from \"@walletconnect/sign-client\";\nimport { EngineTypes, SessionTypes } from \"@walletconnect/types\";\nimport EventEmitter from \"events\";\nimport { PROVIDER_EVENTS } from \"../constants\";\nimport {\n  IProvider,\n  RequestParams,\n  RpcProvidersMap,\n  SessionNamespace,\n  SubProviderOpts,\n} from \"../types\";\nimport { getGlobal, getRpcUrl } from \"../utils\";\n\nclass NearProvider implements IProvider {\n  public name = \"near\";\n  public client: Client;\n  public httpProviders: RpcProvidersMap;\n  public events: EventEmitter;\n  public namespace: SessionNamespace;\n  public chainId: string;\n\n  constructor(opts: SubProviderOpts) {\n    this.namespace = opts.namespace;\n    this.events = getGlobal(\"events\");\n    this.client = getGlobal(\"client\");\n    this.chainId = this.getDefaultChain();\n    this.httpProviders = this.createHttpProviders();\n  }\n\n  public updateNamespace(namespace: SessionTypes.Namespace) {\n    this.namespace = Object.assign(this.namespace, namespace);\n  }\n\n  public requestAccounts(): string[] {\n    return this.getAccounts();\n  }\n\n  public getDefaultChain(): string {\n    if (this.chainId) return this.chainId;\n    if (this.namespace.defaultChain) return this.namespace.defaultChain;\n\n    const chainId = this.namespace.chains[0];\n\n    if (!chainId) throw new Error(`ChainId not found`);\n\n    return chainId.split(\":\")[1];\n  }\n\n  public request<T = unknown>(args: RequestParams): Promise<T> {\n    if (this.namespace.methods.includes(args.request.method)) {\n      return this.client.request(args as EngineTypes.RequestParams);\n    }\n    return this.getHttpProvider().request(args.request);\n  }\n\n  public setDefaultChain(chainId: string, rpcUrl?: string | undefined) {\n    this.chainId = chainId;\n    // http provider exists so just set the chainId\n    if (!this.httpProviders[chainId]) {\n      const rpc = rpcUrl || getRpcUrl(`${this.name}:${chainId}`, this.namespace);\n      if (!rpc) {\n        throw new Error(`No RPC url provided for chainId: ${chainId}`);\n      }\n      this.setHttpProvider(chainId, rpc);\n    }\n\n    this.events.emit(PROVIDER_EVENTS.DEFAULT_CHAIN_CHANGED, `${this.name}:${this.chainId}`);\n  }\n\n  // ---------------- PRIVATE ---------------- //\n\n  private getAccounts(): string[] {\n    const accounts = this.namespace.accounts;\n    if (!accounts) {\n      return [];\n    }\n\n    return (\n      accounts\n        // get the accounts from the active chain\n        .filter((account) => account.split(\":\")[1] === this.chainId.toString())\n        // remove namespace & chainId from the string\n        .map((account) => account.split(\":\")[2]) || []\n    );\n  }\n\n  private createHttpProviders(): RpcProvidersMap {\n    const http = {};\n    this.namespace.chains.forEach((chain) => {\n      http[chain] = this.createHttpProvider(chain, this.namespace.rpcMap?.[chain]);\n    });\n    return http;\n  }\n\n  private getHttpProvider(): JsonRpcProvider {\n    const chain = `${this.name}:${this.chainId}`;\n    const http = this.httpProviders[chain];\n    if (typeof http === \"undefined\") {\n      throw new Error(`JSON-RPC provider for ${chain} not found`);\n    }\n    return http;\n  }\n\n  private setHttpProvider(chainId: string, rpcUrl?: string): void {\n    const http = this.createHttpProvider(chainId, rpcUrl);\n    if (http) {\n      this.httpProviders[chainId] = http;\n    }\n  }\n\n  private createHttpProvider(\n    chainId: string,\n    rpcUrl?: string | undefined,\n  ): JsonRpcProvider | undefined {\n    const rpc = rpcUrl || getRpcUrl(chainId, this.namespace);\n    if (typeof rpc === \"undefined\") return undefined;\n    const http = new JsonRpcProvider(new HttpConnection(rpc, getGlobal(\"disableProviderPing\")));\n    return http;\n  }\n}\n\nexport default NearProvider;\n","import HttpConnection from \"@walletconnect/jsonrpc-http-connection\";\nimport { JsonRpcProvider } from \"@walletconnect/jsonrpc-provider\";\nimport Client from \"@walletconnect/sign-client\";\nimport { EngineTypes, SessionTypes } from \"@walletconnect/types\";\nimport EventEmitter from \"events\";\nimport { PROVIDER_EVENTS } from \"../constants\";\nimport {\n  IProvider,\n  RequestParams,\n  RpcProvidersMap,\n  SessionNamespace,\n  SubProviderOpts,\n} from \"../types\";\n\nimport { getRpcUrl, getGlobal } from \"../utils\";\n\nclass TezosProvider implements IProvider {\n  public name = \"tezos\";\n  public client: Client;\n  public httpProviders: RpcProvidersMap;\n  public events: EventEmitter;\n  public namespace: SessionNamespace;\n  public chainId: string;\n\n  constructor(opts: SubProviderOpts) {\n    this.namespace = opts.namespace;\n    this.events = getGlobal(\"events\");\n    this.client = getGlobal(\"client\");\n    this.chainId = this.getDefaultChain();\n    this.httpProviders = this.createHttpProviders();\n  }\n\n  public updateNamespace(namespace: SessionTypes.Namespace) {\n    this.namespace = Object.assign(this.namespace, namespace);\n  }\n\n  public requestAccounts(): string[] {\n    return this.getAccounts();\n  }\n\n  public getDefaultChain(): string {\n    if (this.chainId) return this.chainId;\n    if (this.namespace.defaultChain) return this.namespace.defaultChain;\n\n    const chainId = this.namespace.chains[0];\n\n    if (!chainId) throw new Error(`ChainId not found`);\n\n    return chainId.split(\":\")[1];\n  }\n\n  public request<T = unknown>(args: RequestParams): Promise<T> {\n    if (this.namespace.methods.includes(args.request.method)) {\n      return this.client.request(args as EngineTypes.RequestParams);\n    }\n    return this.getHttpProvider().request(args.request);\n  }\n\n  public setDefaultChain(chainId: string, rpcUrl?: string | undefined) {\n    this.chainId = chainId;\n    // http provider exists so just set the chainId\n    if (!this.httpProviders[chainId]) {\n      const rpc = rpcUrl || getRpcUrl(`${this.name}:${chainId}`, this.namespace);\n      if (!rpc) {\n        throw new Error(`No RPC url provided for chainId: ${chainId}`);\n      }\n      this.setHttpProvider(chainId, rpc);\n    }\n\n    this.events.emit(PROVIDER_EVENTS.DEFAULT_CHAIN_CHANGED, `${this.name}:${this.chainId}`);\n  }\n\n  // ---------------- PRIVATE ---------------- //\n\n  private getAccounts(): string[] {\n    const accounts = this.namespace.accounts;\n    if (!accounts) {\n      return [];\n    }\n\n    return (\n      accounts\n        // get the accounts from the active chain\n        .filter((account) => account.split(\":\")[1] === this.chainId.toString())\n        // remove namespace & chainId from the string\n        .map((account) => account.split(\":\")[2]) || []\n    );\n  }\n\n  private createHttpProviders(): RpcProvidersMap {\n    const http: any = {};\n    this.namespace.chains.forEach((chain) => {\n      http[chain] = this.createHttpProvider(chain);\n    });\n    return http;\n  }\n\n  private getHttpProvider(): JsonRpcProvider {\n    const chain = `${this.name}:${this.chainId}`;\n    const http = this.httpProviders[chain];\n    if (typeof http === \"undefined\") {\n      throw new Error(`JSON-RPC provider for ${chain} not found`);\n    }\n    return http;\n  }\n\n  private setHttpProvider(chainId: string, rpcUrl?: string): void {\n    const http = this.createHttpProvider(chainId, rpcUrl);\n    if (http) {\n      this.httpProviders[chainId] = http;\n    }\n  }\n\n  private createHttpProvider(\n    chainId: string,\n    rpcUrl?: string | undefined,\n  ): JsonRpcProvider | undefined {\n    const rpc = rpcUrl || getRpcUrl(chainId, this.namespace);\n    if (typeof rpc === \"undefined\") return undefined;\n    const http = new JsonRpcProvider(new HttpConnection(rpc));\n    return http;\n  }\n}\n\nexport default TezosProvider;\n","import HttpConnection from \"@walletconnect/jsonrpc-http-connection\";\nimport { JsonRpcProvider } from \"@walletconnect/jsonrpc-provider\";\nimport Client from \"@walletconnect/sign-client\";\nimport { EngineTypes, SessionTypes } from \"@walletconnect/types\";\nimport EventEmitter from \"events\";\nimport { GENERIC_SUBPROVIDER_NAME, PROVIDER_EVENTS } from \"../constants\";\nimport {\n  IProvider,\n  RequestParams,\n  RpcProvidersMap,\n  SessionNamespace,\n  SubProviderOpts,\n} from \"../types\";\nimport { getGlobal, getRpcUrl } from \"../utils\";\nimport { parseChainId } from \"@walletconnect/utils\";\n\nclass GenericProvider implements IProvider {\n  public name = GENERIC_SUBPROVIDER_NAME;\n  public client: Client;\n  public httpProviders: RpcProvidersMap;\n  public events: EventEmitter;\n  public namespace: SessionNamespace;\n  public chainId: string;\n\n  constructor(opts: SubProviderOpts) {\n    this.namespace = opts.namespace;\n    this.events = getGlobal(\"events\");\n    this.client = getGlobal(\"client\");\n    this.chainId = this.getDefaultChain();\n    this.httpProviders = this.createHttpProviders();\n  }\n\n  public updateNamespace(namespace: SessionTypes.Namespace) {\n    this.namespace.chains = [\n      ...new Set((this.namespace.chains || []).concat(namespace.chains || [])),\n    ];\n    this.namespace.accounts = [\n      ...new Set((this.namespace.accounts || []).concat(namespace.accounts || [])),\n    ];\n    this.namespace.methods = [\n      ...new Set((this.namespace.methods || []).concat(namespace.methods || [])),\n    ];\n    this.namespace.events = [\n      ...new Set((this.namespace.events || []).concat(namespace.events || [])),\n    ];\n    this.httpProviders = this.createHttpProviders();\n  }\n\n  public requestAccounts(): string[] {\n    return this.getAccounts();\n  }\n\n  public request<T = unknown>(args: RequestParams): Promise<T> {\n    if (this.namespace.methods.includes(args.request.method)) {\n      return this.client.request(args as EngineTypes.RequestParams);\n    }\n    return this.getHttpProvider(args.chainId).request(args.request);\n  }\n\n  public setDefaultChain(chainId: string, rpcUrl?: string | undefined) {\n    // http provider exists so just set the chainId\n    if (!this.httpProviders[chainId]) {\n      this.setHttpProvider(chainId, rpcUrl);\n    }\n    this.chainId = chainId;\n    this.events.emit(PROVIDER_EVENTS.DEFAULT_CHAIN_CHANGED, `${this.name}:${chainId}`);\n  }\n\n  public getDefaultChain(): string {\n    if (this.chainId) return this.chainId;\n    if (this.namespace.defaultChain) return this.namespace.defaultChain;\n\n    const chainId = this.namespace.chains[0];\n    if (!chainId) throw new Error(`ChainId not found`);\n\n    return chainId.split(\":\")[1];\n  }\n\n  // --------- PRIVATE --------- //\n\n  private getAccounts(): string[] {\n    const accounts = this.namespace.accounts;\n    if (!accounts) {\n      return [];\n    }\n\n    return [\n      ...new Set(\n        accounts\n          // get the accounts from the active chain\n          .filter((account) => account.split(\":\")[1] === this.chainId.toString())\n          // remove namespace & chainId from the string\n          .map((account) => account.split(\":\")[2]),\n      ),\n    ];\n  }\n\n  private createHttpProviders(): RpcProvidersMap {\n    const http = {};\n    this.namespace?.accounts?.forEach((account) => {\n      const chain = parseChainId(account);\n      http[`${chain.namespace}:${chain.reference}`] = this.createHttpProvider(account);\n    });\n    return http;\n  }\n\n  private getHttpProvider(chain: string): JsonRpcProvider {\n    const http = this.httpProviders[chain];\n    if (typeof http === \"undefined\") {\n      throw new Error(`JSON-RPC provider for ${chain} not found`);\n    }\n    return http;\n  }\n\n  private setHttpProvider(chainId: string, rpcUrl?: string): void {\n    const http = this.createHttpProvider(chainId, rpcUrl);\n    if (http) {\n      this.httpProviders[chainId] = http;\n    }\n  }\n\n  private createHttpProvider(chainId: string, rpcUrl?: string): JsonRpcProvider | undefined {\n    const rpc = rpcUrl || getRpcUrl(chainId, this.namespace, this.client.core.projectId);\n    if (!rpc) {\n      throw new Error(`No RPC url provided for chainId: ${chainId}`);\n    }\n    const http = new JsonRpcProvider(new HttpConnection(rpc, getGlobal(\"disableProviderPing\")));\n    return http;\n  }\n}\n\nexport default GenericProvider;\n","import SignClient from \"@walletconnect/sign-client\";\nimport { SessionTypes } from \"@walletconnect/types\";\nimport { JsonRpcResult } from \"@walletconnect/jsonrpc-types\";\nimport { getSdkError, isValidArray, parseNamespaceKey } from \"@walletconnect/utils\";\nimport { getDefaultLoggerOptions, Logger, pino } from \"@walletconnect/logger\";\nimport {\n  convertChainIdToNumber,\n  getAccountsFromSession,\n  getChainsFromApprovedSession,\n  mergeRequiredOptionalNamespaces,\n  parseCaip10Account,\n  populateNamespacesChains,\n  setGlobal,\n} from \"./utils\";\nimport PolkadotProvider from \"./providers/polkadot\";\nimport Eip155Provider from \"./providers/eip155\";\nimport SolanaProvider from \"./providers/solana\";\nimport CosmosProvider from \"./providers/cosmos\";\nimport AlgorandProvider from \"./providers/algorand\";\nimport CardanoProvider from \"./providers/cardano\";\nimport ElrondProvider from \"./providers/elrond\";\nimport MultiversXProvider from \"./providers/multiversx\";\nimport NearProvider from \"./providers/near\";\nimport TezosProvider from \"./providers/tezos\";\nimport GenericProvider from \"./providers/generic\";\n\nimport {\n  IUniversalProvider,\n  IProvider,\n  RpcProviderMap,\n  ConnectParams,\n  RequestArguments,\n  UniversalProviderOpts,\n  NamespaceConfig,\n  PairingsCleanupOpts,\n  ProviderAccounts,\n  AuthenticateParams,\n} from \"./types\";\n\nimport { RELAY_URL, LOGGER, STORAGE, PROVIDER_EVENTS, GENERIC_SUBPROVIDER_NAME } from \"./constants\";\nimport EventEmitter from \"events\";\nimport { formatJsonRpcResult } from \"@walletconnect/jsonrpc-utils\";\n\nexport class UniversalProvider implements IUniversalProvider {\n  public client!: SignClient;\n  public namespaces?: NamespaceConfig;\n  public optionalNamespaces?: NamespaceConfig;\n  public sessionProperties?: SessionTypes.SessionProperties;\n  public scopedProperties?: SessionTypes.ScopedProperties;\n  public events: EventEmitter = new EventEmitter();\n  public rpcProviders: RpcProviderMap = {};\n  public session?: SessionTypes.Struct;\n  public providerOpts: UniversalProviderOpts;\n  public logger: Logger;\n  public uri: string | undefined;\n\n  private disableProviderPing = false;\n\n  static async init(opts: UniversalProviderOpts) {\n    const provider = new UniversalProvider(opts);\n    await provider.initialize();\n    return provider;\n  }\n\n  constructor(opts: UniversalProviderOpts) {\n    this.providerOpts = opts;\n    this.logger =\n      typeof opts?.logger !== \"undefined\" && typeof opts?.logger !== \"string\"\n        ? opts.logger\n        : pino(getDefaultLoggerOptions({ level: opts?.logger || LOGGER }));\n    this.disableProviderPing = opts?.disableProviderPing || false;\n  }\n\n  public async request<T = unknown>(\n    args: RequestArguments,\n    chain?: string | undefined,\n    expiry?: number | undefined,\n  ): Promise<T> {\n    const [namespace, chainId] = this.validateChain(chain);\n\n    if (!this.session) {\n      throw new Error(\"Please call connect() before request()\");\n    }\n\n    return await this.getProvider(namespace).request({\n      request: {\n        ...args,\n      },\n      chainId: `${namespace}:${chainId}`,\n      topic: this.session.topic,\n      expiry,\n    });\n  }\n\n  public sendAsync(\n    args: RequestArguments,\n    callback: (error: Error | null, response: JsonRpcResult) => void,\n    chain?: string | undefined,\n    expiry?: number | undefined,\n  ): void {\n    const id = new Date().getTime();\n    this.request(args, chain, expiry)\n      .then((response) => callback(null, formatJsonRpcResult(id, response)))\n      .catch((error) => callback(error, undefined as any));\n  }\n\n  public async enable(): Promise<ProviderAccounts> {\n    if (!this.client) {\n      throw new Error(\"Sign Client not initialized\");\n    }\n    if (!this.session) {\n      await this.connect({\n        namespaces: this.namespaces,\n        optionalNamespaces: this.optionalNamespaces,\n        sessionProperties: this.sessionProperties,\n        scopedProperties: this.scopedProperties,\n      });\n    }\n    const accounts = await this.requestAccounts();\n    return accounts as ProviderAccounts;\n  }\n\n  public async disconnect(): Promise<void> {\n    if (!this.session) {\n      throw new Error(\"Please call connect() before enable()\");\n    }\n    await this.client.disconnect({\n      topic: this.session?.topic,\n      reason: getSdkError(\"USER_DISCONNECTED\"),\n    });\n    await this.cleanup();\n  }\n\n  public async connect(opts: ConnectParams): Promise<SessionTypes.Struct | undefined> {\n    if (!this.client) {\n      throw new Error(\"Sign Client not initialized\");\n    }\n    this.setNamespaces(opts);\n    await this.cleanupPendingPairings();\n    if (opts.skipPairing) return;\n\n    return await this.pair(opts.pairingTopic);\n  }\n\n  public async authenticate(opts: AuthenticateParams, walletUniversalLink?: string) {\n    if (!this.client) {\n      throw new Error(\"Sign Client not initialized\");\n    }\n    this.setNamespaces(opts);\n    await this.cleanupPendingPairings();\n\n    const { uri, response } = await this.client.authenticate(opts, walletUniversalLink);\n    if (uri) {\n      this.uri = uri;\n      this.events.emit(\"display_uri\", uri);\n    }\n    const result = await response();\n    this.session = result.session;\n    if (this.session) {\n      // assign namespaces from session if not already defined\n      const approved = populateNamespacesChains(this.session.namespaces) as NamespaceConfig;\n      this.namespaces = mergeRequiredOptionalNamespaces(this.namespaces, approved);\n      await this.persist(\"namespaces\", this.namespaces);\n      this.onConnect();\n    }\n    return result;\n  }\n\n  public on(event: any, listener: any): void {\n    this.events.on(event, listener);\n  }\n\n  public once(event: string, listener: any): void {\n    this.events.once(event, listener);\n  }\n\n  public removeListener(event: string, listener: any): void {\n    this.events.removeListener(event, listener);\n  }\n\n  public off(event: string, listener: any): void {\n    this.events.off(event, listener);\n  }\n\n  get isWalletConnect() {\n    return true;\n  }\n\n  public async pair(pairingTopic: string | undefined): Promise<SessionTypes.Struct> {\n    const { uri, approval } = await this.client.connect({\n      pairingTopic,\n      requiredNamespaces: this.namespaces,\n      optionalNamespaces: this.optionalNamespaces,\n      sessionProperties: this.sessionProperties,\n      scopedProperties: this.scopedProperties,\n    });\n\n    if (uri) {\n      this.uri = uri;\n      this.events.emit(\"display_uri\", uri);\n    }\n\n    const session = await approval();\n    this.session = session;\n    // assign namespaces from session if not already defined\n    const approved = populateNamespacesChains(session.namespaces) as NamespaceConfig;\n    this.namespaces = mergeRequiredOptionalNamespaces(this.namespaces, approved);\n    await this.persist(\"namespaces\", this.namespaces);\n    await this.persist(\"optionalNamespaces\", this.optionalNamespaces);\n\n    this.onConnect();\n    return this.session;\n  }\n\n  public setDefaultChain(chain: string, rpcUrl?: string | undefined) {\n    try {\n      // ignore without active session\n      if (!this.session) return;\n      const [namespace, chainId] = this.validateChain(chain);\n      const provider = this.getProvider(namespace);\n      // @ts-expect-error\n      if (provider.name === GENERIC_SUBPROVIDER_NAME) {\n        provider.setDefaultChain(`${namespace}:${chainId}`, rpcUrl);\n      } else {\n        provider.setDefaultChain(chainId, rpcUrl);\n      }\n    } catch (error) {\n      // ignore the error if the fx is used prematurely before namespaces are set\n      if (!/Please call connect/.test((error as Error).message)) throw error;\n    }\n  }\n\n  public async cleanupPendingPairings(opts: PairingsCleanupOpts = {}): Promise<void> {\n    this.logger.info(\"Cleaning up inactive pairings...\");\n    const inactivePairings = this.client.pairing.getAll();\n\n    if (!isValidArray(inactivePairings)) return;\n\n    for (const pairing of inactivePairings) {\n      if (opts.deletePairings) {\n        this.client.core.expirer.set(pairing.topic, 0);\n      } else {\n        await this.client.core.relayer.subscriber.unsubscribe(pairing.topic);\n      }\n    }\n\n    this.logger.info(`Inactive pairings cleared: ${inactivePairings.length}`);\n  }\n\n  public abortPairingAttempt() {\n    this.logger.warn(\"abortPairingAttempt is deprecated. This is now a no-op.\");\n  }\n\n  // ---------- Private ----------------------------------------------- //\n\n  private async checkStorage() {\n    this.namespaces = (await this.getFromStore(`namespaces`)) || {};\n    this.optionalNamespaces = (await this.getFromStore(`optionalNamespaces`)) || {};\n    if (this.session) this.createProviders();\n  }\n\n  private async initialize() {\n    this.logger.trace(`Initialized`);\n    await this.createClient();\n    await this.checkStorage();\n    this.registerEventListeners();\n  }\n\n  private async createClient() {\n    this.client =\n      this.providerOpts.client ||\n      (await SignClient.init({\n        core: this.providerOpts.core,\n        logger: this.providerOpts.logger || LOGGER,\n        relayUrl: this.providerOpts.relayUrl || RELAY_URL,\n        projectId: this.providerOpts.projectId,\n        metadata: this.providerOpts.metadata,\n        storageOptions: this.providerOpts.storageOptions,\n        storage: this.providerOpts.storage,\n        name: this.providerOpts.name,\n        customStoragePrefix: this.providerOpts.customStoragePrefix,\n        telemetryEnabled: this.providerOpts.telemetryEnabled,\n      }));\n\n    if (this.providerOpts.session) {\n      try {\n        this.session = this.client.session.get(this.providerOpts.session.topic);\n      } catch (error) {\n        this.logger.error(\"Failed to get session\", error);\n        throw new Error(\n          `The provided session: ${this.providerOpts?.session?.topic} doesn't exist in the Sign client`,\n        );\n      }\n    } else {\n      const sessions = this.client.session.getAll();\n      this.session = sessions[0];\n    }\n    this.logger.trace(`SignClient Initialized`);\n  }\n\n  private createProviders(): void {\n    if (!this.client) {\n      throw new Error(\"Sign Client not initialized\");\n    }\n\n    if (!this.session) {\n      throw new Error(\"Session not initialized. Please call connect() before enable()\");\n    }\n\n    const providersToCreate = [\n      ...new Set(\n        Object.keys(this.session.namespaces).map((namespace) => parseNamespaceKey(namespace)),\n      ),\n    ];\n\n    setGlobal(\"client\", this.client);\n    setGlobal(\"events\", this.events);\n    setGlobal(\"disableProviderPing\", this.disableProviderPing);\n\n    providersToCreate.forEach((namespace) => {\n      if (!this.session) return;\n      const accounts = getAccountsFromSession(namespace, this.session);\n      const approvedChains = getChainsFromApprovedSession(accounts);\n      const mergedNamespaces = mergeRequiredOptionalNamespaces(\n        this.namespaces,\n        this.optionalNamespaces,\n      );\n      const combinedNamespace = {\n        ...mergedNamespaces[namespace],\n        accounts,\n        chains: approvedChains,\n      };\n      switch (namespace) {\n        case \"eip155\":\n          this.rpcProviders[namespace] = new Eip155Provider({\n            namespace: combinedNamespace,\n          });\n          break;\n        case \"algorand\":\n          this.rpcProviders[namespace] = new AlgorandProvider({\n            namespace: combinedNamespace,\n          });\n          break;\n        case \"solana\":\n          this.rpcProviders[namespace] = new SolanaProvider({\n            namespace: combinedNamespace,\n          });\n          break;\n        case \"cosmos\":\n          this.rpcProviders[namespace] = new CosmosProvider({\n            namespace: combinedNamespace,\n          });\n          break;\n        case \"polkadot\":\n          this.rpcProviders[namespace] = new PolkadotProvider({\n            namespace: combinedNamespace,\n          });\n          break;\n        case \"cip34\":\n          this.rpcProviders[namespace] = new CardanoProvider({\n            namespace: combinedNamespace,\n          });\n          break;\n        case \"elrond\":\n          this.rpcProviders[namespace] = new ElrondProvider({\n            namespace: combinedNamespace,\n          });\n          break;\n        case \"multiversx\":\n          this.rpcProviders[namespace] = new MultiversXProvider({\n            namespace: combinedNamespace,\n          });\n          break;\n        case \"near\":\n          this.rpcProviders[namespace] = new NearProvider({\n            namespace: combinedNamespace,\n          });\n          break;\n        case \"tezos\":\n          this.rpcProviders[namespace] = new TezosProvider({\n            namespace: combinedNamespace,\n          });\n          break;\n        default:\n          if (!this.rpcProviders[GENERIC_SUBPROVIDER_NAME]) {\n            this.rpcProviders[GENERIC_SUBPROVIDER_NAME] = new GenericProvider({\n              namespace: combinedNamespace,\n            });\n          } else {\n            this.rpcProviders[GENERIC_SUBPROVIDER_NAME].updateNamespace(combinedNamespace);\n          }\n      }\n    });\n  }\n\n  private registerEventListeners(): void {\n    if (typeof this.client === \"undefined\") {\n      throw new Error(\"Sign Client is not initialized\");\n    }\n\n    this.client.on(\"session_ping\", (args) => {\n      const { topic } = args;\n      if (topic !== this.session?.topic) return;\n      this.events.emit(\"session_ping\", args);\n    });\n\n    this.client.on(\"session_event\", (args) => {\n      const { params, topic } = args;\n      if (topic !== this.session?.topic) return;\n      const { event } = params;\n      if (event.name === \"accountsChanged\") {\n        const accounts = event.data;\n        if (accounts && isValidArray(accounts))\n          this.events.emit(\"accountsChanged\", accounts.map(parseCaip10Account));\n      } else if (event.name === \"chainChanged\") {\n        const requestChainId = params.chainId;\n        const payloadChainId = params.event.data as number;\n        const namespace = parseNamespaceKey(requestChainId);\n        // chainIds might differ between the request & payload - request is always in CAIP2 format, while payload might be string, number, CAIP2 or hex\n        // take priority of the payload chainId\n        const chainIdToProcess =\n          convertChainIdToNumber(requestChainId) !== convertChainIdToNumber(payloadChainId)\n            ? `${namespace}:${convertChainIdToNumber(payloadChainId)}`\n            : requestChainId;\n\n        this.onChainChanged(chainIdToProcess);\n      } else {\n        this.events.emit(event.name, event.data);\n      }\n\n      this.events.emit(\"session_event\", args);\n    });\n\n    this.client.on(\"session_update\", ({ topic, params }) => {\n      if (topic !== this.session?.topic) return;\n      const { namespaces } = params;\n      const _session = this.client?.session.get(topic);\n      this.session = { ..._session, namespaces } as SessionTypes.Struct;\n      this.onSessionUpdate();\n      this.events.emit(\"session_update\", { topic, params });\n    });\n\n    this.client.on(\"session_delete\", async (payload) => {\n      if (payload.topic !== this.session?.topic) return;\n      await this.cleanup();\n      this.events.emit(\"session_delete\", payload);\n      this.events.emit(\"disconnect\", {\n        ...getSdkError(\"USER_DISCONNECTED\"),\n        data: payload.topic,\n      });\n    });\n\n    this.on(PROVIDER_EVENTS.DEFAULT_CHAIN_CHANGED, (caip2ChainId: string) => {\n      this.onChainChanged(caip2ChainId, true);\n    });\n  }\n\n  private getProvider(namespace: string): IProvider {\n    return this.rpcProviders[namespace] || this.rpcProviders[GENERIC_SUBPROVIDER_NAME];\n  }\n\n  private onSessionUpdate(): void {\n    Object.keys(this.rpcProviders).forEach((namespace: string) => {\n      this.getProvider(namespace).updateNamespace(\n        this.session?.namespaces[namespace] as SessionTypes.BaseNamespace,\n      );\n    });\n  }\n\n  private setNamespaces(params: ConnectParams): void {\n    const {\n      namespaces = {},\n      optionalNamespaces = {},\n      sessionProperties,\n      scopedProperties,\n    } = params;\n\n    // requiredNamespaces are deprecated, assign them to optionalNamespaces\n    this.optionalNamespaces = mergeRequiredOptionalNamespaces(namespaces, optionalNamespaces);\n    this.sessionProperties = sessionProperties;\n    this.scopedProperties = scopedProperties;\n  }\n\n  private validateChain(chain?: string): [string, string] {\n    const [namespace, chainId] = chain?.split(\":\") || [\"\", \"\"];\n    if (!this.namespaces || !Object.keys(this.namespaces).length) return [namespace, chainId];\n    // validate namespace\n    if (namespace) {\n      if (\n        // some namespaces might be defined with inline chainId e.g. eip155:1\n        // and we need to parse them\n        !Object.keys(this.namespaces || {})\n          .map((key) => parseNamespaceKey(key))\n          .includes(namespace)\n      ) {\n        throw new Error(\n          `Namespace '${namespace}' is not configured. Please call connect() first with namespace config.`,\n        );\n      }\n    }\n    if (namespace && chainId) {\n      return [namespace, chainId];\n    }\n    const defaultNamespace = parseNamespaceKey(Object.keys(this.namespaces)[0]);\n    const defaultChain = this.rpcProviders[defaultNamespace].getDefaultChain();\n    return [defaultNamespace, defaultChain];\n  }\n\n  private async requestAccounts(): Promise<string[]> {\n    const [namespace] = this.validateChain();\n    return await this.getProvider(namespace).requestAccounts();\n  }\n\n  private async onChainChanged(caip2Chain: string, internal = false): Promise<void> {\n    if (!this.namespaces) return;\n\n    const [namespace, chainId] = this.validateChain(caip2Chain);\n\n    if (!chainId) return;\n\n    this.updateNamespaceChain(namespace, chainId);\n\n    this.events.emit(\"chainChanged\", chainId);\n\n    const previousChainId = this.getProvider(namespace).getDefaultChain();\n    if (!internal) {\n      this.getProvider(namespace).setDefaultChain(chainId);\n    }\n\n    this.emitAccountsChangedOnChainChange({ namespace, previousChainId, newChainId: caip2Chain });\n    await this.persist(\"namespaces\", this.namespaces);\n  }\n\n  /**\n   * Emits `accountsChanged` event when a chain is changed and there are new accounts on the new chain\n   */\n  private emitAccountsChangedOnChainChange({\n    namespace,\n    previousChainId,\n    newChainId,\n  }: {\n    namespace: string;\n    previousChainId: string;\n    newChainId: string;\n  }): void {\n    try {\n      if (previousChainId === newChainId) {\n        return;\n      }\n\n      const accounts = this.session?.namespaces[namespace]?.accounts;\n      if (!accounts) return;\n      const newChainIdAccounts = accounts\n        .filter((account) => account.includes(`${newChainId}:`))\n        .map(parseCaip10Account);\n      if (!isValidArray(newChainIdAccounts)) return;\n      this.events.emit(\"accountsChanged\", newChainIdAccounts);\n    } catch (error) {\n      this.logger.warn(\"Failed to emit accountsChanged on chain change\", error);\n    }\n  }\n\n  private updateNamespaceChain(namespace: string, chainId: string): void {\n    if (!this.namespaces) return;\n\n    const namespaceKey = this.namespaces[namespace] ? namespace : `${namespace}:${chainId}`;\n\n    const defaultNamespace = {\n      chains: [],\n      methods: [],\n      events: [],\n      defaultChain: chainId,\n    };\n\n    if (!this.namespaces[namespaceKey]) {\n      this.namespaces[namespaceKey] = defaultNamespace;\n    } else if (this.namespaces[namespaceKey]) {\n      this.namespaces[namespaceKey].defaultChain = chainId;\n    }\n  }\n\n  private onConnect() {\n    this.createProviders();\n    this.events.emit(\"connect\", { session: this.session });\n  }\n\n  private async cleanup() {\n    this.namespaces = undefined;\n    this.optionalNamespaces = undefined;\n    this.sessionProperties = undefined;\n    await this.deleteFromStore(\"namespaces\");\n    await this.deleteFromStore(\"optionalNamespaces\");\n    await this.deleteFromStore(\"sessionProperties\");\n    // reset the session after removing from store as the topic is used there\n    this.session = undefined;\n    await this.cleanupPendingPairings({ deletePairings: true });\n    await this.cleanupStorage();\n  }\n\n  private async persist(key: string, data: unknown) {\n    const topic = this.session?.topic || \"\";\n    await this.client.core.storage.setItem(`${STORAGE}/${key}${topic}`, data);\n  }\n\n  private async getFromStore(key: string) {\n    const topic = this.session?.topic || \"\";\n    return await this.client.core.storage.getItem(`${STORAGE}/${key}${topic}`);\n  }\n\n  private async deleteFromStore(key: string) {\n    const topic = this.session?.topic || \"\";\n    await this.client.core.storage.removeItem(`${STORAGE}/${key}${topic}`);\n  }\n\n  // remove all storage items if there are no sessions left\n  private async cleanupStorage() {\n    try {\n      if (this.client?.session.length > 0) {\n        return;\n      }\n      const keys = await this.client.core.storage.getKeys();\n      for (const key of keys) {\n        if (key.startsWith(STORAGE)) {\n          await this.client.core.storage.removeItem(key);\n        }\n      }\n    } catch (error) {\n      this.logger.warn(\"Failed to cleanup storage\", error);\n    }\n  }\n}\nexport default UniversalProvider;\n","import { UniversalProvider as Provider } from \"./UniversalProvider\";\nexport * from \"./types\";\nexport const UniversalProvider = Provider;\nexport default Provider;\n"],"names":["isTypedArray","cloneDeepWith","chainId","rpc","projectId","_a","chain","parseChainId","RPC_URL","accounts","address","namespace","session","matchedNamespaceKeys","key","accountsForNamespace","required","optional","requiredNamespaces","optionalNamespaces","merge","namespaces","_b","_c","_d","_e","normalizedNamespaces","isValidObject","values","chains","isCaipNamespace","methods","events","rpcMap","normalizedKey","parseNamespaceKey","__spreadProps","__spreadValues","mergeArrays","caip10Account","parsedNamespaces","globals","value","p","a","r","PolkadotProvider","opts","__publicField","getGlobal","args","rpcUrl","PROVIDER_EVENTS","account","http","parsedChainId","getChainId","getRpcUrl","JsonRpcProvider","HttpConnection","Eip155Provider","parsedChain","hexChainId","chainIds","capabilitiesKey","sessionCapabilities","capabilities","error","bundlerName","bundlerUrl","customUrl","url","response","formatJsonRpcRequest","cap2ChainId","BUNDLER_URL","SolanaProvider","CosmosProvider","AlgorandProvider","CardanoProvider","rpcURL","ElrondProvider","MultiversXProvider","NearProvider","TezosProvider","GenericProvider","GENERIC_SUBPROVIDER_NAME","UniversalProvider","EventEmitter","pino","getDefaultLoggerOptions","LOGGER","provider","expiry","callback","id","formatJsonRpcResult","getSdkError","walletUniversalLink","uri","result","approved","populateNamespacesChains","mergeRequiredOptionalNamespaces","event","listener","pairingTopic","approval","inactivePairings","isValidArray","pairing","SignClient","RELAY_URL","sessions","providersToCreate","setGlobal","getAccountsFromSession","approvedChains","getChainsFromApprovedSession","mergedNamespaces","combinedNamespace","topic","params","parseCaip10Account","requestChainId","payloadChainId","chainIdToProcess","convertChainIdToNumber","_session","payload","caip2ChainId","sessionProperties","scopedProperties","defaultNamespace","defaultChain","caip2Chain","internal","previousChainId","newChainId","newChainIdAccounts","namespaceKey","data","STORAGE","keys","Provider"],"mappings":"","ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32],"debugId":null}},
    {"offset": {"line": 1635, "column": 0}, "map": {"version":3,"file":"ConstantsUtil.js","sourceRoot":"","sources":["../../../../src/utils/ConstantsUtil.ts"],"names":[],"mappings":";;;AAGO,MAAM,aAAa,GAAG;IAC3B,cAAc,EAAE,WAAW;IAC3B,qBAAqB,EAAE,SAAS;IAChC,sBAAsB,EAAE,+BAA+B;IACvD,aAAa,EAAE,iCAAiC;IAChD,WAAW,EAAE,2BAA2B;IAExC,YAAY,EAAE;QACZ,cAAc,EAAE,eAAe;QAC/B,QAAQ,EAAE,UAAU;QACpB,eAAe,EAAE,WAAW;QAC5B,QAAQ,EAAE,gBAAgB;QAC1B,YAAY,EAAE,mBAAmB;QACjC,IAAI,EAAE,MAAM;QACZ,MAAM,EAAE,QAAQ;QAChB,GAAG,EAAE,KAAK;QACV,OAAO,EAAE,SAAS;QAClB,IAAI,EAAE,SAAS;KAChB;IACD,eAAe,EAAE;QACf,IAAI,EAAE,MAAM;KACb;IACD,+BAA+B,EAAE;QAAC,QAAQ;QAAE,QAAQ;KAAqB;IACzE,MAAM,EAAE;QACN,oBAAoB,EAAE,EAAE;KACzB;IACD,KAAK,EAAE;QACL,GAAG,EAAE,QAAQ;QACb,MAAM,EAAE,QAAQ;QAChB,QAAQ,EAAE,UAAU;QACpB,OAAO,EAAE,QAAQ;KACgC;IACnD,cAAc,EAAE;QACd,MAAM,EAAE,cAAc;QACtB,MAAM,EAAE,QAAQ;QAChB,QAAQ,EAAE,UAAU;QACpB,MAAM,EAAE,SAAS;QACjB,MAAM,EAAE,QAAQ;KACiC;IACnD,aAAa,EAAE;QACb,OAAO,EAAE,SAAS;QAClB,MAAM,EAAE,QAAQ;QAChB,KAAK,EAAE,OAAO;QACd,MAAM,EAAE,QAAQ;QAChB,OAAO,EAAE,SAAS;KACuB;IAC3C,uBAAuB,EAAE;QAEvB,4CAA4C;QAE5C,4CAA4C;QAE5C,4CAA4C;QAE5C,4CAA4C;QAE5C,4CAA4C;QAE5C,4CAA4C;QAE5C,4CAA4C;KAC7C;IACD,iBAAiB,EAAE;QACjB,mBAAmB,EAAE,GAAG;QACxB,SAAS,EAAE,GAAG;KACf;IACD,wBAAwB,EAAE,iBAAiB;IAC3C,sBAAsB,EACpB,CAAC,OAAO,OAAO,KAAK,WAAW,IAAI,OAAO,OAAO,CAAC,GAAG,KAAK,WAAW,GACjE,OAAO,CAAC,GAAG,CAAC,gCAAgC,CAAC,GAC7C,SAAS,CAAC,IAAI,kCAAkC;CAC9C,CAAA","debugId":null}},
    {"offset": {"line": 1708, "column": 0}, "map": {"version":3,"file":"NetworkUtil.js","sourceRoot":"","sources":["../../../../src/utils/NetworkUtil.ts"],"names":[],"mappings":";;;AAAA,OAAO,EAAE,aAAa,EAAE,MAAM,oBAAoB,CAAA;;AAG3C,MAAM,WAAW,GAAG;IACzB,qBAAqB,EAAC,aAA6B;QACjD,OAAO,aAAa,CAAC,CAAC,CAAC,MAAM,CAAC,aAAa,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,SAAS,CAAA;IACxE,CAAC;IAED,eAAe,EAAC,OAAwB;QACtC,OAAO,OAAO,OAAO,KAAK,QAAQ,GAC9B,IAAI,CAAC,qBAAqB,CAAC,OAAwB,CAAC,GACpD,OAAO,CAAA;IACb,CAAC;IAED,sBAAsB,EAAC,QAAmC,EAAE,SAAyB;QACnF,OAAO,QAAQ,EAAE,MAAM,EAAC,OAAO,CAAC,EAAE,AAAC,OAAO,CAAC,cAAc,KAAK,SAAS,CAAC,IAAI,EAAE,CAAA;IAChF,CAAC;IAED,0BAA0B,EAAC,QAAmC,EAAE,SAAyB;QACvF,OAAO,IAAI,CAAC,sBAAsB,CAAC,QAAQ,EAAE,SAAS,CAAC,CAAC,CAAC,CAAC,CAAA;IAC5D,CAAC;IAED,6BAA6B,EAC3B,YAA2B,EAC3B,aAA4B;QAE5B,IAAI,CAAC,aAAa,EAAE,CAAC;YACnB,OAAO,SAAS,CAAA;QAClB,CAAC;QAED,MAAM,WAAW,GAAG,YAAY,CAAC,IAAI,EAAC,OAAO,CAAC,EAAE,AAAC,OAAO,CAAC,aAAa,KAAK,aAAa,CAAC,CAAA;QAEzF,IAAI,WAAW,EAAE,CAAC;YAChB,OAAO,WAAW,CAAC,IAAI,CAAA;QACzB,CAAC;QAED,MAAM,CAAC,SAAS,CAAC,GAAG,aAAa,CAAC,KAAK,CAAC,GAAG,CAAqB,CAAA;QAEhE,wXAAO,gBAAa,CAAC,cAAc,EAAE,CAAC,SAAS,CAAC,IAAI,SAAS,CAAA;IAC/D,CAAC;CACF,CAAA","debugId":null}},
    {"offset": {"line": 1744, "column": 0}, "map": {"version":3,"file":"ParseUtil.js","sourceRoot":"","sources":["../../../../src/utils/ParseUtil.ts"],"names":[],"mappings":";;;AAaO,MAAM,SAAS,GAAG;IACvB,mBAAmB,EAAC,OAAe;QACjC,IAAI,OAAO,CAAC,KAAK,CAAC,GAAG,CAAC,EAAE,MAAM,KAAK,CAAC,EAAE,CAAC;YACrC,MAAM,IAAI,KAAK,CAAC,sBAAsB,CAAC,CAAA;QACzC,CAAC;QAED,OAAO,OAAsB,CAAA;IAC/B,CAAC;IACD,gBAAgB,EAAC,WAAwB;QACvC,MAAM,KAAK,GAAG,WAAW,CAAC,KAAK,CAAC,GAAG,CAAC,CAAA;QACpC,IAAI,KAAK,CAAC,MAAM,KAAK,CAAC,EAAE,CAAC;YACvB,MAAM,IAAI,KAAK,CAAC,CAAA,yBAAA,EAA4B,WAAW,EAAE,CAAC,CAAA;QAC5D,CAAC;QAED,MAAM,CAAC,cAAc,EAAE,OAAO,EAAE,OAAO,CAAC,GAAG,KAAK,CAAA;QAEhD,IAAI,CAAC,cAAc,IAAI,CAAC,OAAO,IAAI,CAAC,OAAO,EAAE,CAAC;YAC5C,MAAM,IAAI,KAAK,CAAC,CAAA,yBAAA,EAA4B,WAAW,EAAE,CAAC,CAAA;QAC5D,CAAC;QAED,OAAO;YACL,cAAc,EAAE,cAAgC;YAChD,OAAO,EAAE,OAAkB;YAC3B,OAAO;SACR,CAAA;IACH,CAAC;IACD,kBAAkB,EAAC,aAA4B;QAC7C,MAAM,KAAK,GAAG,aAAa,CAAC,KAAK,CAAC,GAAG,CAAC,CAAA;QACtC,IAAI,KAAK,CAAC,MAAM,KAAK,CAAC,EAAE,CAAC;YACvB,MAAM,IAAI,KAAK,CAAC,CAAA,2BAAA,EAA8B,aAAa,EAAE,CAAC,CAAA;QAChE,CAAC;QAED,MAAM,CAAC,cAAc,EAAE,OAAO,CAAC,GAAG,KAAK,CAAA;QAEvC,IAAI,CAAC,cAAc,IAAI,CAAC,OAAO,EAAE,CAAC;YAChC,MAAM,IAAI,KAAK,CAAC,CAAA,2BAAA,EAA8B,aAAa,EAAE,CAAC,CAAA;QAChE,CAAC;QAED,OAAO;YACL,cAAc,EAAE,cAAgC;YAChD,OAAO,EAAE,OAAkB;SAC5B,CAAA;IACH,CAAC;CACF,CAAA","debugId":null}},
    {"offset": {"line": 1790, "column": 0}, "map": {"version":3,"file":"SafeLocalStorage.js","sourceRoot":"","sources":["../../../../src/utils/SafeLocalStorage.ts"],"names":[],"mappings":";;;;;;AA+BO,MAAM,oBAAoB,GAAG;IAClC,SAAS,EAAE,mBAAmB;IAC9B,WAAW,EAAE,qBAAqB;IAClC,aAAa,EAAE,uBAAuB;IACtC,iBAAiB,EAAE,2BAA2B;IAC9C,sBAAsB,EAAE,gCAAgC;IACxD,gBAAgB,EAAE,0BAA0B;IAC5C,yBAAyB,EAAE,gCAAgC;IAC3D,cAAc,EAAE,wBAAwB;IACxC,eAAe,EAAE,+BAA+B;IAChD,gBAAgB,EAAE,0BAA0B;IAC5C,oBAAoB,EAAE,8BAA8B;IACpD,iBAAiB,EAAE,2BAA2B;IAC9C,eAAe,EAAE,yBAAyB;IAC1C,gBAAgB,EAAE,0BAA0B;IAC5C,wBAAwB,EAAE,yBAAyB;IACnD,oBAAoB,EAAE,8BAA8B;IACpD,eAAe,EAAE,yBAAyB;IAC1C,SAAS,EAAE,mBAAmB;IAC9B,cAAc,EAAE,wBAAwB;IACxC,uBAAuB,EAAE,iCAAiC;IAC1D,WAAW,EAAE,qBAAqB;CAC4B,CAAA;AAI1D,SAAU,qBAAqB,CAAC,SAA0B;IAC9D,IAAI,CAAC,SAAS,EAAE,CAAC;QACf,MAAM,IAAI,KAAK,CAAC,kDAAkD,CAAC,CAAA;IACrE,CAAC;IAED,OAAO,CAAA,QAAA,EAAW,SAAS,CAAA,uBAAA,CAAyB,CAAA;AACtD,CAAC;AAEM,MAAM,gBAAgB,GAAG;IAC9B,OAAO,EAAC,GAAwB,EAAE,KAAc;QAC9C,IAAI,MAAM,EAAE,IAAI,KAAK,KAAK,SAAS,EAAE,CAAC;YACpC,YAAY,CAAC,OAAO,CAAC,GAAG,EAAE,KAAK,CAAC,CAAA;QAClC,CAAC;IACH,CAAC;IACD,OAAO,EAAC,GAAwB;QAC9B,IAAI,MAAM,EAAE,EAAE,CAAC;YACb,OAAO,YAAY,CAAC,OAAO,CAAC,GAAG,CAAC,IAAI,SAAS,CAAA;QAC/C,CAAC;QAED,OAAO,SAAS,CAAA;IAClB,CAAC;IACD,UAAU,EAAC,GAAwB;QACjC,IAAI,MAAM,EAAE,EAAE,CAAC;YACb,YAAY,CAAC,UAAU,CAAC,GAAG,CAAC,CAAA;QAC9B,CAAC;IACH,CAAC;IACD,KAAK;QACH,IAAI,MAAM,EAAE,EAAE,CAAC;YACb,YAAY,CAAC,KAAK,EAAE,CAAA;QACtB,CAAC;IACH,CAAC;CACF,CAAA;AAEK,SAAU,MAAM;IACpB,OAAO,OAAO,MAAM,KAAK,WAAW,IAAI,OAAO,YAAY,KAAK,WAAW,CAAA;AAC7E,CAAC","debugId":null}},
    {"offset": {"line": 1857, "column": 0}, "map": {"version":3,"file":"ThemeUtil.js","sourceRoot":"","sources":["../../../../src/utils/ThemeUtil.ts"],"names":[],"mappings":";;;AAoBM,SAAU,oBAAoB,CAAC,cAA+B,EAAE,SAAqB;IACzF,IAAI,SAAS,KAAK,OAAO,EAAE,CAAC;QAC1B,OAAO;YACL,cAAc,EAAE,cAAc,EAAE,CAAC,cAAc,CAAC,IAAI,yBAAyB;YAC7E,kBAAkB,EAAE,MAAM;SAC3B,CAAA;IACH,CAAC;IAED,OAAO;QACL,cAAc,EAAE,cAAc,EAAE,CAAC,cAAc,CAAC,IAAI,yBAAyB;QAC7E,kBAAkB,EAAE,SAAS;KAC9B,CAAA;AACH,CAAC","debugId":null}},
    {"offset": {"line": 1878, "column": 0}, "map": {"version":3,"file":"NumberUtil.js","sourceRoot":"","sources":["../../../../src/utils/NumberUtil.ts"],"names":[],"mappings":";;;AAAA,OAAO,GAAG,MAAM,QAAQ,CAAA;;AAEjB,MAAM,UAAU,GAAG;IAExB,SAAS,EAAC,KAAwC;QAChD,IAAI,CAAC,KAAK,EAAE,CAAC;YACX,OAAO,4LAAI,UAAG,CAAC,CAAC,CAAC,CAAA;QACnB,CAAC;QAED,OAAO,4LAAI,UAAG,CAAC,KAAK,CAAC,CAAA;IACvB,CAAC;IASD,QAAQ,EAAC,CAAoC,EAAE,CAAoC;QACjF,IAAI,CAAC,KAAK,SAAS,IAAI,CAAC,KAAK,SAAS,EAAE,CAAC;YACvC,OAAO,4LAAI,UAAG,CAAC,CAAC,CAAC,CAAA;QACnB,CAAC;QAED,MAAM,UAAU,GAAG,4LAAI,UAAG,CAAC,CAAC,CAAC,CAAA;QAC7B,MAAM,UAAU,GAAG,4LAAI,UAAG,CAAC,CAAC,CAAC,CAAA;QAE7B,OAAO,UAAU,CAAC,KAAK,CAAC,UAAU,CAAC,CAAA;IACrC,CAAC;IAOD,yBAAyB,EAAC,KAAkC,EAAE,QAAQ,GAAG,CAAC;QACxE,IAAI,KAAK,KAAK,SAAS,EAAE,CAAC;YACxB,OAAO,MAAM,CAAA;QACf,CAAC;QAED,IAAI,OAAO,KAAK,KAAK,QAAQ,EAAE,CAAC;YAC9B,OAAO,KAAK,CAAC,cAAc,CAAC,OAAO,EAAE;gBACnC,qBAAqB,EAAE,QAAQ;gBAC/B,qBAAqB,EAAE,QAAQ;aAChC,CAAC,CAAA;QACJ,CAAC;QAED,OAAO,UAAU,CAAC,KAAK,CAAC,CAAC,cAAc,CAAC,OAAO,EAAE;YAC/C,qBAAqB,EAAE,QAAQ;YAC/B,qBAAqB,EAAE,QAAQ;SAChC,CAAC,CAAA;IACJ,CAAC;IAMD,wBAAwB,EAAC,KAAyB;QAChD,IAAI,KAAK,KAAK,SAAS,EAAE,CAAC;YACxB,OAAO,CAAC,CAAA;QACV,CAAC;QAGD,OAAO,UAAU,CAAC,KAAK,CAAC,OAAO,CAAC,KAAK,EAAE,EAAE,CAAC,CAAC,CAAA;IAC7C,CAAC;CACF,CAAA","debugId":null}},
    {"offset": {"line": 1926, "column": 0}, "map": {"version":3,"file":"erc20.js","sourceRoot":"","sources":["../../../../src/contracts/erc20.ts"],"names":[],"mappings":";;;AAAO,MAAM,QAAQ,GAAG;IACtB;QACE,IAAI,EAAE,UAAU;QAChB,IAAI,EAAE,UAAU;QAChB,eAAe,EAAE,YAAY;QAC7B,MAAM,EAAE;YACN;gBACE,IAAI,EAAE,KAAK;gBACX,IAAI,EAAE,SAAS;aAChB;YACD;gBACE,IAAI,EAAE,QAAQ;gBACd,IAAI,EAAE,SAAS;aAChB;SACF;QACD,OAAO,EAAE;YACP;gBACE,IAAI,EAAE,EAAE;gBACR,IAAI,EAAE,MAAM;aACb;SACF;KACF;IACD;QACE,IAAI,EAAE,UAAU;QAChB,IAAI,EAAE,cAAc;QACpB,eAAe,EAAE,YAAY;QAC7B,MAAM,EAAE;YACN;gBACE,IAAI,EAAE,OAAO;gBACb,IAAI,EAAE,SAAS;aAChB;YACD;gBACE,IAAI,EAAE,KAAK;gBACX,IAAI,EAAE,SAAS;aAChB;YACD;gBACE,IAAI,EAAE,QAAQ;gBACd,IAAI,EAAE,SAAS;aAChB;SACF;QACD,OAAO,EAAE;YACP;gBACE,IAAI,EAAE,EAAE;gBACR,IAAI,EAAE,MAAM;aACb;SACF;KACF;CACF,CAAA","debugId":null}},
    {"offset": {"line": 1983, "column": 0}, "map": {"version":3,"file":"swap.js","sourceRoot":"","sources":["../../../../src/contracts/swap.ts"],"names":[],"mappings":";;;AAAO,MAAM,OAAO,GAAG;IACrB;QACE,IAAI,EAAE,UAAU;QAChB,IAAI,EAAE,SAAS;QACf,eAAe,EAAE,YAAY;QAC7B,MAAM,EAAE;YACN;gBAAE,IAAI,EAAE,SAAS;gBAAE,IAAI,EAAE,SAAS;YAAA,CAAE;YACpC;gBAAE,IAAI,EAAE,QAAQ;gBAAE,IAAI,EAAE,SAAS;YAAA,CAAE;SACpC;QACD,OAAO,EAAE;YAAC;gBAAE,IAAI,EAAE,MAAM;YAAA,CAAE;SAAC;KAC5B;CACO,CAAA","debugId":null}},
    {"offset": {"line": 2014, "column": 0}, "map": {"version":3,"file":"usdt.js","sourceRoot":"","sources":["../../../../src/contracts/usdt.ts"],"names":[],"mappings":";;;AAAO,MAAM,OAAO,GAAG;IACrB;QACE,IAAI,EAAE,UAAU;QAChB,IAAI,EAAE,UAAU;QAChB,eAAe,EAAE,YAAY;QAC7B,MAAM,EAAE;YACN;gBACE,IAAI,EAAE,WAAW;gBACjB,IAAI,EAAE,SAAS;aAChB;YACD;gBACE,IAAI,EAAE,QAAQ;gBACd,IAAI,EAAE,SAAS;aAChB;SACF;QACD,OAAO,EAAE,EAAE;KACZ;IACD;QACE,IAAI,EAAE,UAAU;QAChB,IAAI,EAAE,cAAc;QACpB,eAAe,EAAE,YAAY;QAC7B,MAAM,EAAE;YACN;gBACE,IAAI,EAAE,QAAQ;gBACd,IAAI,EAAE,SAAS;aAChB;YACD;gBACE,IAAI,EAAE,WAAW;gBACjB,IAAI,EAAE,SAAS;aAChB;YACD;gBACE,IAAI,EAAE,QAAQ;gBACd,IAAI,EAAE,SAAS;aAChB;SACF;QACD,OAAO,EAAE;YACP;gBACE,IAAI,EAAE,EAAE;gBACR,IAAI,EAAE,MAAM;aACb;SACF;KACF;CACF,CAAA","debugId":null}},
    {"offset": {"line": 2066, "column": 0}, "map": {"version":3,"file":"ContractUtil.js","sourceRoot":"","sources":["../../../../src/utils/ContractUtil.ts"],"names":[],"mappings":";;;AAAA,OAAO,EAAE,QAAQ,EAAE,MAAM,uBAAuB,CAAA;AAChD,OAAO,EAAE,OAAO,EAAE,MAAM,sBAAsB,CAAA;AAC9C,OAAO,EAAE,OAAO,EAAE,MAAM,sBAAsB,CAAA;AAC9C,OAAO,EAAE,aAAa,EAAE,MAAM,oBAAoB,CAAA;;;;;AAE3C,MAAM,YAAY,GAAG;IAC1B,WAAW,EAAE,CAAC,YAAoB,EAAE,EAAE;QAEpC,qXAAI,gBAAa,CAAC,uBAAuB,CAAC,QAAQ,CAAC,YAAY,CAAC,EAAE,CAAC;YACjE,mXAAO,UAAO,CAAA;QAChB,CAAC;QAED,oXAAO,WAAQ,CAAA;IACjB,CAAC;IAED,UAAU,EAAE,GAAG,EAAE,2WAAC,UAAO;CAC1B,CAAA","debugId":null}},
    {"offset": {"line": 2092, "column": 0}, "map": {"version":3,"file":"DateUtil.js","sourceRoot":"","sources":["../../../../src/utils/DateUtil.ts"],"names":[],"mappings":";;;AAAA,OAAO,KAAK,MAAM,OAAO,CAAA;AACzB,OAAO,aAAa,MAAM,oBAAoB,CAAA;AAC9C,OAAO,YAAY,MAAM,8BAA8B,CAAA;AACvD,OAAO,YAAY,MAAM,8BAA8B,CAAA;;;;;0LAEvD,UAAK,CAAC,MAAM,qMAAC,UAAY,CAAC,CAAA;0LAC1B,UAAK,CAAC,MAAM,qMAAC,UAAY,CAAC,CAAA;AAE1B,MAAM,YAAY,GAAG;IACnB,GAAG,oMAAa;IAChB,IAAI,EAAE,eAAe;IACrB,YAAY,EAAE;QACZ,MAAM,EAAE,OAAO;QACf,IAAI,EAAE,QAAQ;QACd,CAAC,EAAE,QAAQ;QACX,CAAC,EAAE,OAAO;QACV,EAAE,EAAE,QAAQ;QACZ,CAAC,EAAE,MAAM;QACT,EAAE,EAAE,QAAQ;QACZ,CAAC,EAAE,KAAK;QACR,EAAE,EAAE,MAAM;QACV,CAAC,EAAE,MAAM;QACT,EAAE,EAAE,OAAO;QACX,CAAC,EAAE,MAAM;QACT,EAAE,EAAE,OAAO;KACZ;CACF,CAAA;AAED,MAAM,WAAW,GAAG;IAClB,SAAS;IACT,UAAU;IACV,OAAO;IACP,OAAO;IACP,KAAK;IACL,MAAM;IACN,MAAM;IACN,QAAQ;IACR,WAAW;IACX,SAAS;IACT,UAAU;IACV,UAAU;CACX,CAAA;0LAED,UAAK,CAAC,MAAM,CAAC,eAAe,EAAE,YAAY,CAAC,CAAA;AAEpC,MAAM,QAAQ,GAAG;IACtB,mBAAmB,EAAC,UAAkB;QACpC,OAAO,WAAW,CAAC,UAAU,CAAC,CAAA;IAChC,CAAC;IACD,OAAO,EAAC,OAAe,IAAI,IAAI,EAAE,CAAC,WAAW,EAAE;QAC7C,qMAAO,UAAA,AAAK,EAAC,IAAI,CAAC,CAAC,IAAI,EAAE,CAAA;IAC3B,CAAC;IAED,sBAAsB,EAAC,IAAqB;QAC1C,QAAO,uMAAA,AAAK,EAAC,IAAI,CAAC,CAAC,MAAM,CAAC,eAAe,CAAC,CAAC,OAAO,CAAC,IAAI,CAAC,CAAA;IAC1D,CAAC;IAED,UAAU,EAAC,IAAqB,EAAE,MAAM,GAAG,QAAQ;QACjD,qMAAO,UAAA,AAAK,EAAC,IAAI,CAAC,CAAC,MAAM,CAAC,MAAM,CAAC,CAAA;IACnC,CAAC;CACF,CAAA","debugId":null}},
    {"offset": {"line": 2159, "column": 0}, "map": {"version":3,"file":"W3mFrameConstants.js","sourceRoot":"","sources":["../../../src/W3mFrameConstants.ts"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 2328, "column": 0}, "map": {"version":3,"file":"ConstantsUtil.js","sourceRoot":"","sources":["../../../src/ConstantsUtil.ts"],"names":[],"mappings":";;;AAEO,MAAM,aAAa,GAAG;IAE3B,sBAAsB,EAAE,UAAU;IAClC,oBAAoB,EAAE,cAAc;IACpC,uBAAuB,EAAE,UAAU;IACnC,sBAAsB,EAAE,SAAS;IACjC,qBAAqB,EAAE,QAAQ;IAC/B,yBAAyB,EAAE,YAAY;IACvC,uBAAuB,EAAE,UAAU;IACnC,qBAAqB,EAAE,eAAe;IACtC,uBAAuB,EAAE,UAAU;IACnC,qBAAqB,EAAE,eAAe;IACtC,sBAAsB,EAAE,SAAS;IAEjC,MAAM,EAAE,QAA0B;IAClC,gBAAgB,EAAE,yBAAyB;IAC3C,sBAAsB,EAAE,0BAA0B;IAClD,qBAAqB,EAAE,yBAAyB;IAChD,kBAAkB,EAAE;QAClB,cAAc,EAAE,qBAAqB;QACrC,iBAAiB,EAAE,qBAAqB;KACf;IAC3B,uBAAuB,EAAE,UAAU;IACnC,6BAA6B,EAAE,gBAAgB;IAC/C,uBAAuB,EAAE,UAAU;IACnC,wBAAwB,EAAE,WAAW;IACrC,mBAAmB,EAAE,MAAM;IAC3B,0BAA0B,EAAE,aAAa;IACzC,uBAAuB,EAAE,SAAS;CACnC,CAAA","debugId":null}},
    {"offset": {"line": 2365, "column": 0}, "map": {"version":3,"file":"HelpersUtil.js","sourceRoot":"","sources":["../../../src/HelpersUtil.ts"],"names":[],"mappings":";;;AAGA,OAAO,EAAE,aAAa,EAAE,MAAM,oBAAoB,CAAA;;AAE3C,MAAM,WAAW,GAAG;IACzB,aAAa,EAAC,MAAe;QAC3B,IAAI,CAAC,MAAM,EAAE,CAAC;YACZ,OAAO,SAAS,CAAA;QAClB,CAAC;QAED,MAAM,UAAU,GAAW,CAAA,CAAE,CAAA;QAC7B,MAAM,CAAC,OAAO,CAAC,MAAM,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC,EAAE,EAAE,KAAK,CAAC,EAAE,EAAE;YAC7C,UAAU,CAAC,wYAAG,gBAAa,CAAC,MAAM,CAAA,CAAA,EAAI,EAAE,EAAmB,CAAC,GAAG,KAAK,CAAA;QACtE,CAAC,CAAC,CAAA;QAEF,OAAO,UAAU,CAAA;IACnB,CAAC;IAED,gBAAgB,EAAC,IAAa,EAAE,IAAa;QAC3C,OAAO,IAAI,EAAE,WAAW,EAAE,KAAK,IAAI,EAAE,WAAW,EAAE,CAAA;IACpD,CAAC;CACF,CAAA","debugId":null}},
    {"offset": {"line": 2391, "column": 0}, "map": {"version":3,"file":"PresetsUtil.js","sourceRoot":"","sources":["../../../src/PresetsUtil.ts"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 2508, "column": 0}, "map": {"version":3,"file":"CaipNetworkUtil.js","sourceRoot":"","sources":["../../../src/CaipNetworkUtil.ts"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 2725, "column": 0}, "map": {"version":3,"file":"ErrorUtil.js","sourceRoot":"","sources":["../../../src/ErrorUtil.ts"],"names":[],"mappings":";;;AAAA,MAAM,eAAe,GAAG,IAAI,eAAe,EAAE,CAAA;AAEtC,MAAM,SAAS,GAAG;IACvB,6BAA6B,EAAE,eAAe;IAC9C,uBAAuB,EAAE;QACvB,+BAA+B,EAAE;YAC/B,OAAO,EAAE,kCAAkC;YAC3C,aAAa,EAAE,2BAA2B;SAC3C;QACD,oBAAoB,EAAE;YACpB,OAAO,EAAE,kDAAkD;YAC3D,aAAa,EAAE,qBAAqB;SACrC;QACD,WAAW,EAAE;YACX,OAAO,EAAE,2BAA2B;YACpC,aAAa,EAAE,oBAAoB;SACpC;KACF;IACD,YAAY,EAAE;QACZ,wBAAwB,EAAE;YACxB,YAAY,EAAE,mBAAmB;YACjC,WAAW,EACT,kGAAkG;SACrG;QACD,yBAAyB,EAAE;YACzB,YAAY,EAAE,2BAA2B;YACzC,WAAW,EAAE,GAAG,CACd,CAAA,AADgB,OAChB,EACE,MAAM,EAAE,CAAC,CAAC,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC,CAAC,SAC7B,CAAA,iEAAA,CAAmE;SACtE;QACD,kBAAkB,EAAE;YAClB,YAAY,EAAE,gDAAgD;YAC9D,WAAW,EAAE,GAAG,CAAG,CAAD,wEAA0E;SAC7F;QACD,sBAAsB,EAAE;YACtB,YAAY,EAAE,mCAAmC;YACjD,WAAW,EAAE,GAAG,CACd,CADgB,qFACsE;SACzF;QACD,iBAAiB,EAAE;YACjB,YAAY,EAAE,2BAA2B;YACzC,WAAW,EAAE,GAAG,CACd,CADgB,6GAC8F;SACjH;QAED,mBAAmB,EAAE;YACnB,YAAY,EAAE,iBAAiB;YAC/B,WAAW,EACT,gGAAgG;SACnG;QACD,kBAAkB,EAAE;YAClB,YAAY,EAAE,2BAA2B;YACzC,WAAW,EAAE,2CAA2C;SACzD;QACD,yBAAyB,EAAE;YACzB,YAAY,EAAE,2BAA2B;YACzC,WAAW,EAAE,qEAAqE;SACnF;KACF;CACF,CAAA;AAED,SAAS,MAAM;IACb,OAAO,OAAO,MAAM,KAAK,WAAW,CAAA;AACtC,CAAC","debugId":null}},
    {"offset": {"line": 2789, "column": 0}, "map": {"version":3,"file":"LoggerUtil.js","sourceRoot":"","sources":["../../../src/LoggerUtil.ts"],"names":[],"mappings":";;;AAAA,OAAO,EAAE,sBAAsB,EAAE,uBAAuB,EAAE,MAAM,uBAAuB,CAAA;;;AAEhF,MAAM,UAAU,GAAG;IACxB,YAAY,EAAC,OAAoD,EAAE,KAAK,GAAG,OAAO;QAChF,MAAM,aAAa,IAAG,oRAAA,AAAuB,EAAC;YAC5C,KAAK;SACN,CAAC,CAAA;QAEF,MAAM,EAAE,MAAM,EAAE,8PAAG,yBAAA,AAAsB,EAAC;YACxC,IAAI,EAAE,aAAa;SACpB,CAAC,CAAA;QAEF,MAAM,CAAC,KAAK,GAAG,CAAC,GAAG,IAAe,EAAE,EAAE;YACpC,KAAK,MAAM,GAAG,IAAI,IAAI,CAAE,CAAC;gBACvB,IAAI,GAAG,YAAY,KAAK,EAAE,CAAC;oBACzB,OAAO,CAAC,GAAG,EAAE,GAAG,IAAI,CAAC,CAAA;oBAErB,OAAM;gBACR,CAAC;YACH,CAAC;YAED,OAAO,CAAC,SAAS,EAAE,GAAG,IAAI,CAAC,CAAA;QAC7B,CAAC,CAAA;QAED,OAAO,MAAM,CAAA;IACf,CAAC;CACF,CAAA","debugId":null}},
    {"offset": {"line": 2821, "column": 0}, "map": {"version":3,"file":"ProviderUtil.js","sourceRoot":"","sources":["../../../src/ProviderUtil.ts"],"names":[],"mappings":";;;AACA,OAAO,EAAE,KAAK,EAAE,GAAG,EAAE,SAAS,EAAE,MAAM,gBAAgB,CAAA;AACtD,OAAO,EAAE,YAAY,IAAI,MAAM,EAAE,MAAM,sBAAsB,CAAA;;;AAqB7D,MAAM,qBAAqB,GAAG;IAC5B,MAAM,EAAE,SAAS;IACjB,MAAM,EAAE,SAAS;IACjB,QAAQ,EAAE,SAAS;IACnB,MAAM,EAAE,SAAS;IACjB,MAAM,EAAE,SAAS;CAClB,CAAA;AAED,MAAM,KAAK,8PAAG,QAAK,AAAL,EAA8B;IAC1C,SAAS,EAAE;QAAE,GAAG,qBAAqB;IAAA,CAAE;IACvC,WAAW,EAAE;QAAE,GAAG,qBAAqB;IAAA,CAAE;CAC1C,CAAC,CAAA;AAEK,MAAM,YAAY,GAAG;IAC1B,KAAK;IAEL,YAAY,EAAqB,GAAM,EAAE,QAAoD;QAC3F,2RAAO,eAAM,AAAN,EAAO,KAAK,EAAE,GAAG,EAAE,QAAQ,CAAC,CAAA;IACrC,CAAC;IAED,SAAS,EAAC,QAAiD;QACzD,kQAAO,YAAA,AAAS,EAAC,KAAK,EAAE,GAAG,EAAE;YAC3B,QAAQ,CAAC,KAAK,CAAC,CAAA;QACjB,CAAC,CAAC,CAAA;IACJ,CAAC;IAED,kBAAkB,EAAC,QAAkE;QACnF,QAAO,sQAAS,AAAT,EAAU,KAAK,CAAC,SAAS,EAAE,GAAG,CAAG,CAAD,OAAS,CAAC,KAAK,CAAC,SAAS,CAAC,CAAC,CAAA;IACpE,CAAC;IAED,WAAW,EAAwB,cAA8B,EAAE,QAAW;QAC5E,IAAI,QAAQ,EAAE,CAAC;YACb,KAAK,CAAC,SAAS,CAAC,cAAc,CAAC,IAAG,gQAAA,AAAG,EAAC,QAAQ,CAAM,CAAA;QACtD,CAAC;IACH,CAAC;IAED,WAAW,EAAwB,cAA8B;QAC/D,OAAO,KAAK,CAAC,SAAS,CAAC,cAAc,CAAkB,CAAA;IACzD,CAAC;IAED,aAAa,EAAC,cAA8B,EAAE,UAAyB;QACrE,IAAI,UAAU,EAAE,CAAC;YACf,KAAK,CAAC,WAAW,CAAC,cAAc,CAAC,GAAG,UAAU,CAAA;QAChD,CAAC;IACH,CAAC;IAED,aAAa,EAAC,cAA0C;QACtD,IAAI,CAAC,cAAc,EAAE,CAAC;YACpB,OAAO,SAAS,CAAA;QAClB,CAAC;QAED,OAAO,KAAK,CAAC,WAAW,CAAC,cAAc,CAAC,CAAA;IAC1C,CAAC;IAED,KAAK;QACH,KAAK,CAAC,SAAS,GAAG;YAAE,GAAG,qBAAqB;QAAA,CAAE,CAAA;QAC9C,KAAK,CAAC,WAAW,GAAG;YAAE,GAAG,qBAAqB;QAAA,CAAE,CAAA;IAClD,CAAC;IAED,UAAU,EAAC,cAA8B;QACvC,KAAK,CAAC,SAAS,CAAC,cAAc,CAAC,GAAG,SAAS,CAAA;QAC3C,KAAK,CAAC,WAAW,CAAC,cAAc,CAAC,GAAG,SAAS,CAAA;IAC/C,CAAC;CACF,CAAA","debugId":null}},
    {"offset": {"line": 2894, "column": 0}, "map": {"version":3,"file":"ConstantsUtil.js","sourceRoot":"","sources":["../../../../src/utils/ConstantsUtil.ts"],"names":[],"mappings":";;;AAEO,MAAM,aAAa,GAAG;IAC3B,YAAY,EAAE;QAAC;YAAE,KAAK,EAAE,QAAQ;QAAA,CAAE;QAAE;YAAE,KAAK,EAAE,MAAM;QAAA,CAAE;QAAE;YAAE,KAAK,EAAE,UAAU;QAAA,CAAE;KAAC;IAC7E,kBAAkB,EAEhB,CAAC,OAAO,OAAO,KAAK,WAAW,IAAI,OAAO,OAAO,CAAC,GAAG,KAAK,WAAW,GACjE,OAAO,CAAC,GAAG,CAAC,gCAAgC,CAAC,GAC7C,SAAS,CAAC,IAAI,kCAAkC;IACtD,cAAc,EAAE;QACd,IAAI,EAAE,MAAM;QACZ,IAAI,EAAE,MAAM;KACb;IACD,4BAA4B,EAAE;QAAC,OAAO;QAAE,QAAQ;QAAE,QAAQ;KAAoB;IAC9E,mBAAmB,EAAE;QACnB,UAAU,EAAE,GAAG;QACf,WAAW,EAAE,GAAG;QAChB,cAAc,EAAE,GAAG;KACpB;CACF,CAAA","debugId":null}},
    {"offset": {"line": 2931, "column": 0}, "map": {"version":3,"file":"WalletUtil.js","sourceRoot":"","sources":["../../../../src/utils/WalletUtil.ts"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 3040, "column": 0}, "map": {"version":3,"file":"ConnectorUtil.js","sourceRoot":"","sources":["../../../../src/utils/ConnectorUtil.ts"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 3168, "column": 0}, "map": {"version":3,"file":"utils.js","sourceRoot":"","sources":["../../../exports/utils.tsx"],"names":[],"mappings":";AAAA,cAAc,+BAA+B,CAAA;AAC7C,cAAc,+BAA+B,CAAA;AAC7C,cAAc,4BAA4B,CAAA","debugId":null}},
    {"offset": {"line": 3192, "column": 0}, "map": {"version":3,"file":"MathUtil.js","sourceRoot":"","sources":["../../../../src/utils/MathUtil.ts"],"names":[],"mappings":";;;AAAO,MAAM,QAAQ,GAAG;IAQtB,WAAW,EAAC,UAAoB,EAAE,WAAqB,EAAE,KAAa;QACpE,IAAI,UAAU,CAAC,MAAM,KAAK,CAAC,IAAI,WAAW,CAAC,MAAM,KAAK,CAAC,EAAE,CAAC;YACxD,MAAM,IAAI,KAAK,CAAC,yDAAyD,CAAC,CAAA;QAC5E,CAAC;QAED,MAAM,gBAAgB,GAAG,UAAU,CAAC,CAAC,CAAC,IAAI,CAAC,CAAA;QAC3C,MAAM,gBAAgB,GAAG,UAAU,CAAC,CAAC,CAAC,IAAI,CAAC,CAAA;QAC3C,MAAM,WAAW,GAAG,WAAW,CAAC,CAAC,CAAC,IAAI,CAAC,CAAA;QACvC,MAAM,WAAW,GAAG,WAAW,CAAC,CAAC,CAAC,IAAI,CAAC,CAAA;QAEvC,IAAI,KAAK,GAAG,gBAAgB,EAAE,CAAC;YAC7B,OAAO,WAAW,CAAA;QACpB,CAAC;QACD,IAAI,KAAK,GAAG,gBAAgB,EAAE,CAAC;YAC7B,OAAO,WAAW,CAAA;QACpB,CAAC;QAED,OAAO,AACL,AAAC,CAAC,WAAW,GAAG,WAAW,CAAC,GAAG,CAAC,gBAAgB,GAAG,gBAAgB,CAAC,CAAC,EACnE,CAAC,KAAK,GAAG,gBAAgB,CAAC,GAC5B,WAAW,CACZ,CAAA;IACH,CAAC;CACF,CAAA","debugId":null}},
    {"offset": {"line": 3219, "column": 0}, "map": {"version":3,"file":"ThemeUtil.js","sourceRoot":"","sources":["../../../../src/utils/ThemeUtil.ts"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 4157, "column": 0}, "map": {"version":3,"file":"UiHelperUtil.js","sourceRoot":"","sources":["../../../../src/utils/UiHelperUtil.ts"],"names":[],"mappings":";;;AAGO,MAAM,YAAY,GAAG;IAC1B,gBAAgB,EAAC,OAAoC,EAAE,KAAa;QAClE,IAAI,KAAK,CAAC,OAAO,CAAC,OAAO,CAAC,EAAE,CAAC;YAC3B,OAAO,OAAO,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAA,kBAAA,EAAqB,OAAO,CAAC,KAAK,CAAC,CAAA,CAAA,CAAG,CAAC,CAAC,CAAC,SAAS,CAAA;QAC5E,CAAC,MAAM,IAAI,OAAO,OAAO,KAAK,QAAQ,EAAE,CAAC;YACvC,OAAO,CAAA,kBAAA,EAAqB,OAAO,CAAA,CAAA,CAAG,CAAA;QACxC,CAAC;QAED,OAAO,SAAS,CAAA;IAClB,CAAC;IAED,gBAAgB,EAAC,IAAU;QACzB,OAAO,IAAI,IAAI,CAAC,cAAc,CAAC,OAAO,EAAE;YAAE,KAAK,EAAE,OAAO;YAAE,GAAG,EAAE,SAAS;QAAA,CAAE,CAAC,CAAC,MAAM,CAAC,IAAI,CAAC,CAAA;IAC1F,CAAC;IAED,WAAW,EAAC,GAAW;QACrB,IAAI,CAAC;YACH,MAAM,MAAM,GAAG,IAAI,GAAG,CAAC,GAAG,CAAC,CAAA;YAE3B,OAAO,MAAM,CAAC,QAAQ,CAAA;QACxB,CAAC,CAAC,OAAO,KAAK,EAAE,CAAC;YACf,OAAO,EAAE,CAAA;QACX,CAAC;IACH,CAAC;IAED,iBAAiB,EAAC,EAAE,MAAM,EAAE,UAAU,EAAE,QAAQ,EAAE,QAAQ,EAAmB;QAC3E,IAAI,MAAM,CAAC,MAAM,IAAI,UAAU,GAAG,QAAQ,EAAE,CAAC;YAC3C,OAAO,MAAM,CAAA;QACf,CAAC;QAED,IAAI,QAAQ,KAAK,KAAK,EAAE,CAAC;YACvB,OAAO,GAAG,MAAM,CAAC,SAAS,CAAC,CAAC,EAAE,UAAU,CAAC,CAAA,GAAA,CAAK,CAAA;QAChD,CAAC,MAAM,IAAI,QAAQ,KAAK,OAAO,EAAE,CAAC;YAChC,OAAO,CAAA,GAAA,EAAM,MAAM,CAAC,SAAS,CAAC,MAAM,CAAC,MAAM,GAAG,QAAQ,CAAC,EAAE,CAAA;QAC3D,CAAC;QAED,OAAO,GAAG,MAAM,CAAC,SAAS,CAAC,CAAC,EAAE,IAAI,CAAC,KAAK,CAAC,UAAU,CAAC,CAAC,CAAA,GAAA,EAAM,MAAM,CAAC,SAAS,CACzE,MAAM,CAAC,MAAM,GAAG,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC,CACrC,EAAE,CAAA;IACL,CAAC;IAED,oBAAoB,EAAC,OAAe;QAClC,MAAM,IAAI,GAAG,OAAO,CACjB,WAAW,EAAE,CACb,OAAO,CAAC,OAAO,EAAE,EAAE,CAAC,CACpB,OAAO,CAAC,aAAa,EAAE,EAAE,CAAC,CAAA;QAC7B,MAAM,SAAS,GAAG,IAAI,CAAC,SAAS,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC,EAAE,GAAG,CAAC,CAAA;QACrD,MAAM,QAAQ,GAAG,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,CAAA;QACzC,MAAM,kBAAkB,GAAG,gBAAgB,CAAC,QAAQ,CAAC,eAAe,CAAC,CAAC,gBAAgB,CACpF,4BAA4B,CAC7B,CAAA;QACD,MAAM,MAAM,GAAG,MAAM,CAAC,kBAAkB,EAAE,OAAO,CAAC,IAAI,EAAE,EAAE,CAAC,CAAC,CAAA;QAC5D,MAAM,IAAI,GAAG,GAAG,GAAG,CAAC,GAAG,MAAM,CAAA;QAE7B,MAAM,cAAc,GAAG,GAAG,IAAI,CAAA,EAAA,EAAK,IAAI,CAAA,YAAA,CAAc,CAAA;QAErD,MAAM,MAAM,GAAa,EAAE,CAAA;QAE3B,IAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,CAAC,EAAE,CAAC,IAAI,CAAC,CAAE,CAAC;YAC9B,MAAM,WAAW,GAAG,IAAI,CAAC,SAAS,CAAC,QAAQ,EAAE,IAAI,GAAG,CAAC,CAAC,CAAA;YACtD,MAAM,CAAC,IAAI,CAAC,CAAA,IAAA,EAAO,WAAW,CAAC,CAAC,CAAC,CAAA,EAAA,EAAK,WAAW,CAAC,CAAC,CAAC,CAAA,EAAA,EAAK,WAAW,CAAC,CAAC,CAAC,CAAA,CAAA,CAAG,CAAC,CAAA;QAC7E,CAAC;QAED,OAAO,CAAA;uBACY,MAAM,CAAC,CAAC,CAAC,CAAA;uBACT,MAAM,CAAC,CAAC,CAAC,CAAA;uBACT,MAAM,CAAC,CAAC,CAAC,CAAA;uBACT,MAAM,CAAC,CAAC,CAAC,CAAA;uBACT,MAAM,CAAC,CAAC,CAAC,CAAA;6BACH,cAAc,CAAA;IACvC,CAAA;IACF,CAAC;IAED,QAAQ,EAAC,GAAW;QAClB,MAAM,MAAM,GAAG,QAAQ,CAAC,GAAG,EAAE,EAAE,CAAC,CAAA;QAEhC,MAAM,CAAC,GAAG,AAAC,MAAM,IAAI,EAAE,CAAC,EAAG,GAAG,CAAA;QAC9B,MAAM,CAAC,GAAG,AAAC,MAAM,IAAI,CAAC,CAAC,EAAG,GAAG,CAAA;QAC7B,MAAM,CAAC,GAAG,MAAM,GAAG,GAAG,CAAA;QAEtB,OAAO;YAAC,CAAC;YAAE,CAAC;YAAE,CAAC;SAAC,CAAA;IAClB,CAAC;IAED,SAAS,EAAC,GAA6B,EAAE,IAAY;QACnD,MAAM,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,GAAG,GAAG,CAAA;QACrB,MAAM,OAAO,GAAG,IAAI,CAAC,KAAK,CAAC,CAAC,GAAG,CAAC,GAAG,GAAG,CAAC,CAAC,GAAG,IAAI,CAAC,CAAA;QAChD,MAAM,OAAO,GAAG,IAAI,CAAC,KAAK,CAAC,CAAC,GAAG,CAAC,GAAG,GAAG,CAAC,CAAC,GAAG,IAAI,CAAC,CAAA;QAChD,MAAM,OAAO,GAAG,IAAI,CAAC,KAAK,CAAC,CAAC,GAAG,CAAC,GAAG,GAAG,CAAC,CAAC,GAAG,IAAI,CAAC,CAAA;QAEhD,OAAO;YAAC,OAAO;YAAE,OAAO;YAAE,OAAO;SAAC,CAAA;IACpC,CAAC;IAED,QAAQ,EAAC,SAAiB;QACxB,MAAM,KAAK,GAAG;YACZ,MAAM,EAAE,WAAW;SACpB,CAAA;QAED,OAAO,KAAK,CAAC,MAAM,CAAC,IAAI,CAAC,SAAS,CAAC,CAAA;IACrC,CAAC;IAED,aAAa,EAAC,KAA4B;QACxC,IAAI,KAAK,EAAE,CAAC;YACV,OAAO,KAAK,CAAA;QACd,CAAC,MAAM,IAAI,OAAO,MAAM,KAAK,WAAW,IAAI,MAAM,CAAC,UAAU,EAAE,CAAC;YAC9D,IAAI,MAAM,CAAC,UAAU,CAAC,8BAA8B,CAAC,EAAE,OAAO,EAAE,CAAC;gBAC/D,OAAO,MAAM,CAAA;YACf,CAAC;YAED,OAAO,OAAO,CAAA;QAChB,CAAC;QAED,OAAO,MAAM,CAAA;IACf,CAAC;IACD,YAAY,EAAC,KAAa;QACxB,MAAM,KAAK,GAAG,KAAK,CAAC,KAAK,CAAC,GAAG,CAAqB,CAAA;QAClD,IAAI,KAAK,CAAC,MAAM,KAAK,CAAC,EAAE,CAAC;YACvB,OAAO;gBAAC,KAAK,CAAC,CAAC,CAAC;gBAAE,KAAK,CAAC,CAAC,CAAC;aAAC,CAAA;QAC7B,CAAC;QAED,OAAO;YAAC,GAAG;YAAE,IAAI;SAAC,CAAA;IACpB,CAAC;IACD,WAAW,EAAC,MAAc,EAAE,SAAiB,EAAE,KAAa;QAC1D,MAAM,aAAa,GACjB,MAAM,CAAC,QAAQ,EAAE,CAAC,MAAM,IAAI,SAAS,CAAC,CAAC,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,MAAM,CAAA;QAEhF,OAAO,aAAa,CAAA;IACtB,CAAC;IAOD,yBAAyB,EAAC,KAAkC,EAAE,QAAQ,GAAG,CAAC;QACxE,IAAI,KAAK,KAAK,SAAS,EAAE,CAAC;YACxB,OAAO,MAAM,CAAA;QACf,CAAC;QAED,IAAI,OAAO,KAAK,KAAK,QAAQ,EAAE,CAAC;YAC9B,OAAO,KAAK,CAAC,cAAc,CAAC,OAAO,EAAE;gBACnC,qBAAqB,EAAE,QAAQ;gBAC/B,qBAAqB,EAAE,QAAQ;aAChC,CAAC,CAAA;QACJ,CAAC;QAED,OAAO,UAAU,CAAC,KAAK,CAAC,CAAC,cAAc,CAAC,OAAO,EAAE;YAC/C,qBAAqB,EAAE,QAAQ;YAC/B,qBAAqB,EAAE,QAAQ;SAChC,CAAC,CAAA;IACJ,CAAC;CACF,CAAA","debugId":null}},
    {"offset": {"line": 4294, "column": 0}, "map": {"version":3,"file":"TransactionUtil.js","sourceRoot":"","sources":["../../../../src/utils/TransactionUtil.ts"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 4448, "column": 0}, "map": {"version":3,"file":"WebComponentsUtil.js","sourceRoot":"","sources":["../../../../src/utils/WebComponentsUtil.ts"],"names":[],"mappings":";;;AAuBA,SAAS,qBAAqB,CAAC,OAAe,EAAE,UAA2B;IACzE,MAAM,EAAE,IAAI,EAAE,QAAQ,EAAE,GAAG,UAAU,CAAA;IAErC,OAAO;QACL,IAAI;QACJ,QAAQ;QACR,QAAQ,EAAC,KAA+B;YACtC,IAAI,CAAC,cAAc,CAAC,GAAG,CAAC,OAAO,CAAC,EAAE,CAAC;gBACjC,cAAc,CAAC,MAAM,CAAC,OAAO,EAAE,KAAK,CAAC,CAAA;YACvC,CAAC;QACH,CAAC;KACF,CAAA;AACH,CAAC;AAED,SAAS,mBAAmB,CAAC,OAAe,EAAE,KAA+B;IAC3E,IAAI,CAAC,cAAc,CAAC,GAAG,CAAC,OAAO,CAAC,EAAE,CAAC;QACjC,cAAc,CAAC,MAAM,CAAC,OAAO,EAAE,KAAK,CAAC,CAAA;IACvC,CAAC;IAED,OAAO,KAAY,CAAA;AACrB,CAAC;AAEK,SAAU,aAAa,CAAC,OAAe;IAC3C,OAAO,SAAS,MAAM,CAAC,iBAA6D;QAClF,OAAO,OAAO,iBAAiB,KAAK,UAAU,GAC1C,mBAAmB,CAAC,OAAO,EAAE,iBAAiB,CAAC,GAC/C,qBAAqB,CAAC,OAAO,EAAE,iBAAiB,CAAC,CAAA;IACvD,CAAC,CAAA;AACH,CAAC","debugId":null}},
    {"offset": {"line": 4480, "column": 0}, "map": {"version":3,"file":"index.js","sourceRoot":"","sources":["../../../exports/index.ts"],"names":[],"mappings":";AAAA,OAAO,EAAE,QAAQ,EAAE,MAAM,0BAA0B,CAAA;AACnD,OAAO,EAAE,iBAAiB,EAAE,aAAa,EAAE,iBAAiB,EAAE,MAAM,2BAA2B,CAAA;AAC/F,OAAO,EAAE,YAAY,EAAE,MAAM,8BAA8B,CAAA;AAC3D,OAAO,EAAE,eAAe,EAAE,MAAM,iCAAiC,CAAA;AACjE,OAAO,EAAE,aAAa,EAAE,MAAM,mCAAmC,CAAA","debugId":null}}]
}